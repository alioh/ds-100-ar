---
title: دورة حياة علم البيانات
show_title: true
chapter_number: 1
chapter_text: الفصل الأول
chapter_lessons: [[0, 'مقدمة'], [1, 'طلاب داتا 100'], [2, 'إستكشاف البيانات'], [3, 'ماذا بداخل عامود الأسم؟']]
layout: default
---

## {{page.chapter_text}}: {{page.title}}

<h2>مقدمة</h2>

في علم البيانات، نستخدم بيانات عديدة ومتنوعة لإتخاذ قراراتنا. في هذا الكتاب سنشرح المبادئ والتقنيات لعلم البيانات من الجانب الحسابي والتفكير الإستدلالي. ويشمل الخطوات التاليه:
- تشكيل السؤال أو المشكلة.
- إيجاد وتنظيف البيانات.
- إستكشاف البيانات.
- إستخدام التوقع والإستدلال لإيجاد النتائج.

ومن المتوقع أن تظهر مزيد من الأسئلة والمشاكل بعد آخر خطوة، في ذلك الوقت يمكننا إعادة الخطوات مرة أخرى لإكتشاف الخصائص الجديدة في مشكلتنا. هذا التكرار الإيجابي في عملنا يسمى **<u>دورة حياة علم البيانات</u>**.

إذا كانت دورة حياة علم البيانات سهلة، لما احتجنا كتباً لشرحها. لحسن حظنا، كل خطوة لديها عدد مختلف من التحديات التي تكشف لنا أفكار جديده تكون هي أساساً لإتخاذ قرارات مدروسة بإستخدام البيانات.

<h2>طلاب داتا 100</h2>

دورة حياة علم البيانات تتكون من الخطوات التاليه:

1- **تشكيل السؤال أو المشكلة**:
- ما الذي تريد معرفته، أو ما هي المشكلة التي تريد حلها؟
- ما هي الفرضيات؟
- ما هي مقاييس نجاحنا؟

2- **إيجاد وتنظيف البيانات**:
- ما هي البيانات المتوفرة لدينا وما هي التي نبحث عنها؟
- كيف سنتمكن من جمع المزيد من البيانات؟
- كيف نرتب البيانات لبدأ التحليل؟

3- **إستكشاف البيانات**:
- هل لدينا بيانات ذات علاقة بمشكلتنا؟
- هل تحتوي البيانات على تحيزات، بيانات شاذة، أو مشاكل أخرى؟
- كيف نحول البيانات لتساعدنا على القيام بتحليل فعال؟

4- **التوقع والإستدلال**:
- ماذا تخبرنا البيانات؟
- هل أجابت على السؤال أو حلت المشكلة؟
- ما مدى قوة نتائجنا؟


سنقوم الآن بتجربة هذة الخطوات على قاعدة بيانات الأسماء الأولى للطلاب من الفصول السابقة لداتا 100. في هذا الفصل، قمنا بالمرور بشكل سريع على الخطوات لإعطاء القارئ معلومات عن الدورة الكاملة. في فصول لاحقة، سنتحدث بشكل مفصل ونشرح كل خطوة.

### تشكيل السؤال أو المشكلة

نريد أن نعرف ما إذا كان الإسمالأول للطلاب يقدم لنا معلومات إضافية عنهم. رغم أن السؤال يبدو غامضاً نوعاً ما، لكنه كافي لجعلنا نعمل على البيانات المتوفرة لدينا ويمكننا التعديل في السؤال أثناء عملنا لنجعله أكثر دقة.

### إيجاد وتنظيف البيانات

لنبدأ بأخذ نظرة سريعة على البيانات المتوفرة لدينا، البيانات هي قائمة لأسماء الطلاب الأولى للذين سبق أن درسوا مادة داتا 100.
**<u>لا تقلق أن لم تفهم الكود البرمجي؛ سنشرحه ونشرح المكتبات المستخدمة لاحقاً</u>**. حالياً، ركز على الخطوات والرسوم البيانية:

```python
import pandas as pd

students = pd.read_csv('roster.csv')
students
```

|**Name**|**Role**||
:-----:|:-----:|:-----:
|Keeley|Student|0|
|John|Student|1|
|BRYAN|Student|2|
|...|...|...|
|Ernesto|Waitlist Student|276|
|Athan|Waitlist Student|277|
|Michael|Waitlist Student|278|

```center-result
279 rows × 2 columns
```

يمكن أن نلاحظ بشكل سريع وجود بعض المشاكل في بياناتنا. مثلاً، أحدى الطلاب كُتب أسمة بالأحرف الكبيرة بشكل كامل BRYAN. وأيضاً لا يبدو واضح معنى العامود Role. يحتوي الجدول على عامودين و 279 سطر.

**في هذه المادة، سنتعلم كيف نكتشف الأخطاء في بياناتنا وتصحيحها**. الإختلاف في الحروف الكبيرة في الإسم Brayn سيجعل البرنامج يتوقع أن BRAYN يختلف عن Brayn ولكن في الحقيقه هما نفس الشخص. لذا سنحول جميع الأسماء لحروف صغيرة:

```python
students['Name'] = students['Name'].str.lower()
students
```

|**Name**|**Role**||
:-----:|:-----:|:-----:
|keeley|Student|0|
|john|Student|1|
|bryan|Student|2|
|...|...|...|
|ernesto|Waitlist Student|276|
|athan|Waitlist Student|277|
|michael|Waitlist Student|278|

```center-result
279 rows × 2 columns
```
  

الآن، وبما أن البيانات لدينا بدأت تظهر بشكل مقبول، يمكننا الإنتقال للخطوة التالية.

<h2>إستكشاف البيانات</h2>

إستكشاف البيانات أو Exploratory Data Analysis وإختصارها EDA يطلق على الخطوات التي نتبعها لمعرفة صفات البيانات. لنستعرض بيانات الطلاب:

```python
students
```

|**Name**|**Role**||
:-----:|:-----:|:-----:
|keeley|Student|0|
|john|Student|1|
|bryan|Student|2|
|...|...|...|
|ernesto|Waitlist Student|276|
|athan|Waitlist Student|277|
|michael|Waitlist Student|278|

```center-result
279 rows × 2 columns
```

الآن لدينا بعض الأسئلة، كم عدد الطلاب؟ ماذا يعني عامود Role؟ نقوم بخطوة أستكشاف البيانات للإجابة على مثل هذه الأسئلة.

### كم عدد الطلاب؟

```python
print("There are", len(students), "students on the roster.")
```

```ruby
There are 279 students on the roster.
```


عدد الطلاب لدينا 279 طالباً. السؤال التالي دائماً يكون: هل تحتوي البيانات على كامل الطلاب؟ في حالتنا، الجدول يحتوي على جميع الطلاب الذين درسوا فصلاً واحد لمادة داتا 100.


### ماذا يعني عامود `Role`؟

لنكتشف البيانات التي في هذا العامود لنعرف معناه:

```python
students['Role'].value_counts().to_frame()
```

|**Role**||
:-----:|:-----:|
|237|Student|
|42|Waitlist Student|

يمكن أن نرى في الجدول السابق أن البيانات لا تحتوي فقط على الطلاب الذين درسوا المادة Student، بل أيضاً على الطلاب الموجودين في قائمة الأنتظار Waitlist Student. إذاً، العامود Role يخبرنا إذا كان الطالب ألتحق بالمادة أم لا.


### ماذا عن عامود Name؟ كيف يمكننا إستكشافه؟

في هذه المادة سنتعامل مع عدد كبير من أنواع البيانات. الرقمية، النوعية والنصية. كل نوع له أسلوب وأدوات خاصة للإستكشاف.

طريقة سريعة لفهم عامود الأسماء Name هي بمعرفة عدد الأحرف في كل إسم:

```python
sns.distplot(students['Name'].str.len(),
             rug=True,
             bins=np.arange(12),
             axlabel="Number of Characters")
plt.xlim(0, 12)
plt.xticks(np.arange(12))
plt.ylabel('Proportion per character');
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter1/1.jpg'>
</p>

الرسم البياني السابق يخبرنا أن أكثر الأسماء يبلغ طولها بين 4 إلى 8 أحرف. هذا يساعدنا على معرفه ما إذا كانت بياناتنا معقولة أم لا. إذا كان هناك الكثير من الأسماء ذات حرف واحد، فيكون ذلك سبب مناسب لإعادة إستكشاف البيانات.

### ماذا بداخل عامود الإسم؟

رغم أن البيانات تبدو واضحة وبسيطة، سنعرف لاحقاً كيف أن الإسمالأول فقط قد يخبرنا الكثير عن مجموعة الطلاب لدينا.

<h2>ماذا بداخل عامود الأسم؟</h2>

حتى الآن، وجهنا سؤال عام: "هل يخبرنا الإسم الأول للطالب اي شئ عن المادة؟"

قمنا بتنظيف البيانات بتحويلها جميعها لأحرف صغيره. أثناء إستكشاف البيانات لاحظنا أن لدينا حوالي 270 طالباً منهم من درس المادة ومن على قائمة الإنتظار. وأكثر الأسماء بين 4 إلى 8 أحرف.

ماذا يمكننا معرفته عن طلاب المادة من أسمائهم؟ لنأخذ أسم واحد منها:

```python
students['Name'][5]
```

```ruby
'jerry'
```

من هذا الإسم، يمكننا القول أن صاحب الإسمذكر. ويمكننا أيضاً توقع عمر الطالب. على سبيل المثال، إذا عرفنا أن إسم Jerry مشهور من بين أسماء الأطفال الذين ولدو في عام 1998، يمكننا التوقع أن عمر الطالب في العشرينيات.

التفكير بهذه الطريقة أوصلنا إلى سؤالين:

- هل يخبرنا أسم الطلاب عن توزيع الذكور والإناث؟
- هل يخبرنا أسم الطلاب عن توزيع الأعمار؟

للإجابه على هذه الأسئلة، سنحتاج بيانات تربط بين الأسماء مع الجنس والسنوات. مؤسسة الضمان الإجتماعي الأمريكية لديها مثل هذه البيانات ومتوفرة على الإنترنت على [الرابط](https://www.ssa.gov/oact/babynames/index.html).

سنبدأ أولاً بتحميل البيانات من الموقع ثم نقلها إلى بايثون. مرة أخرى، **لا تقلق إذا لم تفهم الكود البرمجي في هذا الفصل، فقط ركز على فهم الخطوات بشكل عام**:

```python
import urllib.request
import os.path

data_url = "https://www.ssa.gov/oact/babynames/names.zip"
local_filename = "babynames.zip"
if not os.path.exists(local_filename): # اذا توفرت البيانات، لا تحملها مرة أخرى
    with urllib.request.urlopen(data_url) as resp, open(local_filename, 'wb') as f:
        f.write(resp.read())
        
import zipfile
babynames = [] 
with zipfile.ZipFile(local_filename, "r") as zf:
    data_files = [f for f in zf.filelist if f.filename[-3:] == "txt"]
    def extract_year_from_filename(fn):
        return int(fn[3:7])
    for f in data_files:
        year = extract_year_from_filename(f.filename)
        with zf.open(f) as fp:
            df = pd.read_csv(fp, names=["Name", "Sex", "Count"])
            df["Year"] = year
            babynames.append(df)
babynames = pd.concat(babynames)
babynames
```

|**Year**|**Count**|**Sex**|**Name**||
:-----:|:-----:|:-----:|:-----:|:-----:
|1884|9217|F|Mary|0|
|1884|3860|F|Anna|1|
|1884|2587|F|Emma|2|
|...|...|...|
|1883|5|M|Verna|2081|
|1883|5|M|Winnie|2082|
|1883|5|M|Winthrop|2083|

```center-result
1891894 rows × 4 columns
```

البيانات تحتوي على الأسماء، جنس الطفل، عدد الأطفال بهذا الإسموسنة ميلادهم. للتأكيد لنقرأ ما كتبه مكتب الضمان الإجتماعي في شرحهم للبيانات على [الرابط](https://www.ssa.gov/oact/babynames/background.html).

> جميع الأسماء أتت من بطاقات التقديم للضمان الإجتماعي لجميع الولادات التي كانت في الولايات المتحدة بعد 1879. **ملاحظة**: الكثير مِن مَن ولدو قبل 1937 لم يقدمو للحصول على البطاقة، لذا أسمائهم ليست ضمن البيانات. الآخرين الذين قدموا طلباتهم، بياناتنا قد لا تبين مكان ولادتهم، لذا أسمائهم لم تضاف للبيانات.
> هذي عينة كاملة من البيانات لدينا حتى تاريخ مارس 2017.

نبدأ أولاً بعرض عدد المواليد الذكور والإناث كل سنة:

```python
pivot_year_name_count = pd.pivot_table(
    babynames, index='Year', columns='Sex',
    values='Count', aggfunc=np.sum)

pink_blue = ["#E188DB", "#334FFF"]
with sns.color_palette(sns.color_palette(pink_blue)):
    pivot_year_name_count.plot(marker=".")
    plt.title("Registered Names vs Year Stratified by Sex")
    plt.ylabel('Names Registered that Year')
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter1/YearVsSex.jpg'>
</p>

الزيادة المفائجة بعدد المواليد في عام 1920 تبدو مشبوهه، ولكن في الإقتباس السابق تم توضيح السبب:

> **ملاحظة**: الكثير مِن مَن ولدو قبل 1937 لم يقدمو للحصول على البطاقة، لذا أسمائهم ليست ضمن البيانات. الآخرين الذين قدموا طلباتهم، بياناتنا قد لا تبين مكان ولادتهم، لذا أسمائهم لم تضاف للبيانات.

يمكن ملاحظة فترة الإنجاب المتزايدة أو ما تسمى ب Baby boomers والتي كانت في الفتره بين 1946 حتى 1964، لقراءة المزيد عن هذا الموضوع قم بزيارة [الرابط](https://www.wikiwand.com/en/Baby_boomers).


### معرفة الجنس من الأسم

لنستخدم بيانات الأطفال السابقة لمعرفة عدد الذكور والإناث. كما فعلنا سابقاً، نبدأ أولاً بتصغير جميع أحرف الأسماء في بيانات الأطفال:

```python
babynames['Name'] = babynames['Name'].str.lower()
babynames
```

|**Year**|**Count**|**Sex**|**Name**||
:-----:|:-----:|:-----:|:-----:|:-----:
|1884|9217|F|mary|0|
|1884|3860|F|anna|1|
|1884|2587|F|emma|2|
|...|...|...|
|1883|5|M|verna|2081|
|1883|5|M|winnie|2082|
|1883|5|M|winthrop|2083|

```center-result
2084 rows × 4 columns
```

ثم نجمع عدد المواليد لكل أسم ونوع المولود:

```python
sex_counts = pd.pivot_table(babynames, index='Name', columns='Sex',
                            values='Count', aggfunc='sum',
                            fill_value=0., margins=True)
sex_counts
```

|**All**|**M**|**F**|**Sex**|
:-----:|:-----:|:-----:|:-----:|
| | | |Name|
|96|96|0|aaban|
|35|0|35|aabha|
|10|10|0|aabid|
|...|...|...|
|6|6|0|zyyon|
|5|5|0|zzyzx|
|344533897|173894326|170639571|All|

```center-result
96175 rows × 3 columns
```

لمعرفه نسبة شهرة الإسمبين الجنسين، يمكننا إيجاب نسبة تكرار الإسملدى أحداهما:

```python
prop_female = sex_counts['F'] / sex_counts['All']
sex_counts['prop_female'] = prop_female
sex_counts
```

|**prop_female**|**All**|**M**|**F**|**Sex**|
:-----:|:-----:|:-----:|:-----:|
| | | | |Name|
|0.0|96|96|0|aaban|
|1.0|35|0|35|aabha|
|0.0|10|10|0|aabid|
|...|...|...|
|0.0|6|6|0|zyyon|
|0.0|5|5|0|zzyzx|
|0.5|344533897|173894326|170639571|All|

```center-result
96175 rows × 4 columns
```

يمكننا تعريف دالة لتبحث لنا عن ما إذا كان الإسمذكراً او أنثى بإستخدام النسبة السابقة:

```python
def sex_from_name(name):
    if name in sex_counts.index:
        prop = sex_counts.loc[name, 'prop_female']
        return 'F' if prop > 0.5 else 'M'
    else:
        return 'Name not in dataset'

sex_from_name('sam')
```

```ruby
'M'
```


بإستخدام الكود البرمجي السابق يمكنك تجربة أي إسم واستنتاج ما إذا كانت نسبة تسميتة كذكر أكثر أم كأنثى.

الآن لنعود لبيانات الطلاب ونضيف عليها ما إذا كان الطالب ذكراً أو أنثى:

|**Sex**|**Name**|**Role**||
:-----:|:-----:|:-----:
|F|keeley|Student|0|
|M|john|Student|1|
|M|bryan|Student|2|
|...|...|...|
|M|ernesto|Waitlist Student|276|
|M|athan|Waitlist Student|277|
|M|michael|Waitlist Student|278|

```center-result
279 rows × 4 columns
```


الآن يمكننا بسهولة معرفة عدد الذكور والإناث بين طلابنا:

```python
students['sex'].value_counts()
```


```ruby
M                      144
F                       92
Name not in dataset     43
Name: Sex, dtype: int64
```


### إيجاد العمر من الأسم

بإستخدام نفس الطريقة السابقة يمكننا إيجاد توزيع العمر في فصلنا، بربط كل أسم مع متوسط السنوات الذي تكرر فيها:

```python
def avg_year(group):
    return np.average(group['Year'], weights=group['Count'])

avg_years = (
    babynames
    .groupby('Name')
    .apply(avg_year)
    .rename('avg_year')
    .to_frame()
)
avg_years
```

|**avg_year**|
:-----:|:-----:
| |Name|
|2012.57|aaban|
|2013.71|aabha|
|2009.50|aabid|
|...|...|
|2010.00|zyyanna|
|2014.00|zyyon|
|2010.00|zzyzx|

```center-result
96174 rows × 1 columns
```

بنفس الطريقة السابقة، يمكن أن نبحث عن أي إسم ونجد متوسط سنة الميلاد:

```python
def year_from_name(name):
    return (avg_years.loc[name, 'avg_year']
            if name in avg_years.index
            else None)

students['year'] = students['Name'].apply(year_from_name)
students
```

|**Year**|**Sex**|**Name**|**Role**||
:-----:|:-----:|:-----:
|1998.15|F|keeley|Student|0|
|1951.08|M|john|Student|1|
|1983.57|M|bryan|Student|2|
|...|...|...|
|1981.44|M|ernesto|Waitlist Student|276|
|2004.40|M|athan|Waitlist Student|277|
|1971.18|M|michael|Waitlist Student|278|

```center-result
279 rows × 4 columns
```


الآن، يمكننا بسهولة عرض توزيع السنوات بين الطلاب:

```python
sns.distplot(students['year'].dropna());
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter1/StudentYears.jpg'>
</p>

ولعرض متوسط عامود السنة نقوم بالآتي:

```python
students['year'].mean()
```

```ruby
1983.846741800525
```


متوسط الأعمار لدينا هو 35 سنه (2018-1983=35)، تقريباً أكثر مرتين من العمر المتوقع للطلاب الجامعيين. لماذا تظهر لنا البيانات مرتفعه بهذا الشكل؟

كعالم بيانات، قد نصل لنتائج لا نتفق معها أو عكس توقعاتنا. التحدي الدائم الذي يواجهنا هو معرفة ما إذا كانت النتائج التي فاجئتنا سببها خطأ في أحدى خطواتنا أو خطأ حقيقي في البيانات. بما أنه لا يوجد هناك طريقة سهله لضمان نتائج دقيقه، عالم البيانات يجب أن يكون لديه مبادئ وقواعد للتقليل من إيجاد نتائج خاطئة.

في حالتنا، التفسير الوحيد للنتيجة الغير متوقعة التي ظهرت لنا هو أن الأسماء الأكثر شيوعاً تستخدم منذ سنوات عديدة. مثلاً الإسم John يعتبر من الأسماء الأكثر شيوعاً عبر التاريخ بناءاً على البيانات التي حصلنا عليها. يمكننا تأكيد ذلك بعرض رسم بياني بعدد الأطفال الذين تم تسميتهم John كل سنة:

```python
names = babynames.set_index('Name').sort_values('Year')
john = names.loc['john']
john[john['Sex'] == 'M'].plot('Year', 'Count')
plt.title('Frequency of "John"');
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter1/JohnOverTheYears.jpg'>
</p>

يبدو لنا أن متوسط السنة لا يعطي توقع دقيق لعمر الشخص. ولكن في بعض الحالات، الإسم الأول للشخص يساعدنا بذلك، على سبيل المثال عند التجربة على إسم Kanye تظهر لنا النتيجة التالية:

```python
names = babynames.set_index('Name').sort_values('Year')
kanye = names.loc['kanye']
kanye[kanye['Sex'] == 'M'].plot('Year', 'Count')
plt.title('Frequency of "Kanye"');
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter1/KANYE.jpg'>
</p>

### ملخص الفصل الأول

في هذا الفصل، قمنا بالمرور بشكل سريع على دورة حياة علم البيانات: تشكيل السؤال أو المشكلة، إيجاد وتنظيف البيانات، إستشكاف البيانات، التوقع والإستدلال. سنشرح بشكل مفصل عن كل دورة في الفصول القادمة.

النصف الأول من الكتاب (الفصل 1 حتى 9) ستغطي الثلاث خطوات الأولى لدورة حياة علم البيانات وتركز بشكل كبير على طريقة الحساب وإيجاد النتائج. النصف الثاني (الفصل 10 حتى 18) يستخدم التفكير الحسابي والإحصائي لتغطية مواضيع بناء النماذج، الإستدلال والتوقع.

بشكل عام، يسعى هذا الكتاب لتعريف القارئ بالمبادئ وتقنيات علم البيانات.
