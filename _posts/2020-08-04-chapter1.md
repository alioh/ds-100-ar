---
title: دورة حياة علم البيانات
show_title: true
chapter_number: 1
chapter_lessons: [[0, 'مقدمة'], [1, 'طلاب داتا 100'], [2, 'إستكشاف البيانات'], [3, 'ماذا بداخل عامود الأسم؟']]
layout: default
---

## مقدمة

في علم البيانات، نستخدم بيانات عديده ومتنوعه لإتخاذ قراراتنا. في هذا الكتاب سنشرح المبادئ والتقنيات لعلم البيانات من الجانب الحسابي والتفكير الإستدلالي. وهذا يشمل الخطوات التاليه:
- تشكيل السؤال أو المشكلة.
- إيجاد وتنظيف البيانات.
- إستكشاف البيانات.
- إستخدام التوقع والإستدلال لإيجاد النتائج.

ومن المتوقع ان تظهر مزيد من الأسئلة والمشاكل بعد آخر خطوة في القائمة السابقة، وقتها يمكننا إعادة الخطوات مرة أخرى لإكتشاف الخصائص الجديدة في مشكلتنا. هذا التكرار الإيجابي في عملنا يسمى **<u>دورة حياة علم البيانات</u>**.

إذا كانت دورة حياة علم البيانات سهلة، لما احتجنا كتباً لشرحها. لحسن حظنا، كل خطوة لديها عدد مختلف من التحديات التي تكشف لنا أفكار جديده تكون هي أساساً لإتخاذ قرارات مدروسة بإستخدام البيانات.
{{title}}
## <a name="#طلاب داتا 100">طلاب داتا 100</a>

دورة حياة علم البيانات تتكون من الخطوات التاليه:

1- **تشكيل السؤال أو المشكلة**:
- ما الذي تريد معرفته، أو ما هي المشكلة التي تريد حلها؟
- ما هي الفرضيات؟
- ما هي مقاييس نجاحنا؟

2- **إيجاد وتنظيف البيانات**:
- ما هي البيانات المتوفرة لدينا وما هي التي نبحث عنها؟
- كيف سنتمكن من جمع المزيد من البيانات؟
- كيف نرتب البيانات بدأ التحليل؟

3- **إستكشاف البيانات**:
- هل لدينا بيانات ذات علاقة بمشكلتنا؟
- هل تحتوي البيانات على تحيزات، بيانات شاذة، أو مشاكل أخرى؟
- كيف نحول البيانات لتساعدنا على عمل تحليل فعال؟

4- **التوقع والإستدلال**:
- ماذا تقول البيانات؟
- هل أجابت على السؤال أو حلت المشكلة؟
- ما مدى قوة نتائجنا؟


سنقوم الان بتجربة هذة الخطوات على قاعدة بيانات الأسماء الأولى للطلاب من الفصول السابقة لداتا 100. في هذا الفصل، قمنا بالمرور بشكل سريع على الخطوات لإعطاء القارئ معلومات عن الدورة الكاملة. في فصول لاحقة، سنتحدث بتفصيل ونشرح مبادئ وتقنيات كل خطوة.

### تشكيل السؤال أو المشكلة

نريد ان نعرف ما اذا كان الأسم الأول للطلالب يعطينا معلومات اضافية عن الطلاب نفسهم. رغم ان هذا السؤال غامضاً نوعاً ما، فأنه كافي لجعلنا نعمل على البيانات المتوفرة لدينا ويمكننا التعديل من السؤال اثناء عملنا لنجعله أكثر دقة.

### إيجاد وتنظيف البيانات

لنبدأ بأخذ نظرة سريعة على البيانات المتوفرة لدينا، البيانات هي قائمة لأسماء الطلاب الأولى للذين سبق أن درسوا مادة داتا 100.
**<u>لا تقلق أن لم تفهم الكود البرمجي؛ سنشرح المكتبات المستخدمة لاحقاً</u>**. حالياً، ركز على الخطوات والرسوم البيانية:

```python
import pandas as pd

students = pd.read_csv('roster.csv')
students
```

|**Name**|**Role**||
:-----:|:-----:|:-----:
|Keeley|Student|0|
|John|Student|1|
|BRYAN|Student|2|
|...|...|...|
|Ernesto|Waitlist Student|276|
|Athan|Waitlist Student|277|
|Michael|Waitlist Student|278|

```center-result
279 rows × 2 columns
```

يمكن أن نلاحظ بشكل سريع وجود بعض المشاكل في بياناتنا. مثلاً، أحدى الطلاب كُتب أسمة بالأحرف الكبيرة بشكل كامل `BRYAN`. وايضاً لا يبدو واضح معنى العامود `Role`. البيانات تحتوي على عامودين و 279 سطر.

**في هذه المادة، سنتعلم كيف نكتشف الأخطاء في بياناتنا وتصحيحها**. الأختلاف في الحروف الكبيرة في الأسم `Brayn` سيجعل البرنامج يتوقع ان `BRAYN` يختلف عن `Brayn` ولكن هما متشابهين لدينا. لذا نحول جميع الأسماء لحروف صغيرة:

```python
students['Name'] = students['Name'].str.lower()
students
```

|**Name**|**Role**||
:-----:|:-----:|:-----:
|keeley|Student|0|
|john|Student|1|
|bryan|Student|2|
|...|...|...|
|ernesto|Waitlist Student|276|
|athan|Waitlist Student|277|
|michael|Waitlist Student|278|

```center-result
279 rows × 2 columns
```
  

الآن، وبما أن البيانات لدينا بدأت تظهر بشكل مقبول، يمكننا الإنتقال للخطوة التالية.

## إستكشاف البيانات 

إستكشاف البيانات أو Exploratory Data Analysis وإختصارها `EDA` يطلق على الخطوات التي نتبعها لمعرفة صفات البيانات. لنعرض بيانات الطلاب التي سبق ان عرضناها في الجزء السابق:

```python
students
```

|**Name**|**Role**||
:-----:|:-----:|:-----:
|keeley|Student|0|
|john|Student|1|
|bryan|Student|2|
|...|...|...|
|ernesto|Waitlist Student|276|
|athan|Waitlist Student|277|
|michael|Waitlist Student|278|

```center-result
279 rows × 2 columns
```

الآن لدينا بعض الأسئلة، كم عدد الطلاب لدينا؟ ماذا يعني عامود `Role` نقوم بخطوة أستكشاف البيانات للإجابة على مثل هذه الأسئلة. في الغالب، نستكشف البيانات بالإجابة على اسئلة تظهر لنا المزيد من المعلومات عن البيانات التي نعمل عليها.

### كم عدد الطلاب؟

```python
print("There are", len(students), "students on the roster.")
```

```ruby
There are 279 students on the roster.
```


عدد الطلاب لدينا 279 طالب. السؤال التالي دائماً يكون: هل تحتوي البيانات على كامل الطلاب؟ في الحالة التي لدينا، الجدول يحتوي على جميع الطلاب الذين درسوا فصل واحد لمادة داتا 100.


### ماذا يعني عامود `Role`؟

لنكتشف البيانات التي في هذا العامود لنعرف ما يعنيه:

```python
students['Role'].value_counts().to_frame()
```

|**Role**||
:-----:|:-----:|
|237|Student|
|42|Waitlist Student|

يمكن ان نرى في الجدول السابق ان البيانات لدينا لا تحتوي فقط على الطلاب الذين درسوا المادة فقط `Student`، بل أيضاً الطلاب على قائمة الأنتظار `Waitlist Student`. العامود `Role` يخبرنا اذا كان الطالب ألتحق بالمادة أم لا.


### ماذا عن الأسماء؟ كيف يمكننا تلخيص هذا العامود؟

في هذه المادة سنعمل على عدد كبير من أنواع البيانات. الرقمية، النوعية، والنصية. كل نوع له أسلوب وأدوات خاصة للإستكشاف.

طريقة سريعة لفهم عامود الأسماء `Name` هي عن طريق معرفة عدد الأحرف في كل اسم:

```python
sns.distplot(students['Name'].str.len(),
             rug=True,
             bins=np.arange(12),
             axlabel="Number of Characters")
plt.xlim(0, 12)
plt.xticks(np.arange(12))
plt.ylabel('Proportion per character');
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter1/1.jpg'>
</p>

الرسم البياني السابق يخبرنا أن أكثر الأسماء يبلغ طولها بين 4 إلى 8 أحرف. هذا يساعدنا على معرفه ما إذا كانت بياناتنا معقولة أم لا. إذا كان هناك الكثير من الأسماء ذات حرف واحد، فيكون ذلك سبب مناسب لإعادة إستكشاف البيانات.

### ماذا بداخل عامود الأسم ؟

رغم أن البيانات تبدو واضحة وبسيطة، سنعرف لاحقاً كيف أن الأسم الأول فقط قد يخبرنا الكثير عن مجموعة الطلاب لدينا.

## ماذا بداخل عامود الأسم؟

حتى الآن، وجهنا سؤال بشكل عام: "هل يخبرنا الأسم الأول للطالب اي شئ عن المادة؟"

قمنا بتنظيف البيانات لدينا بتحويلها جميعها لأحرف صغيره. أثناء إستكشاف البيانات لاحظنا ان لدينا حوالي 270 طالباً في المادة وقائمة الإنتظار. وأكثر طول الأسماء لدينا بين 4 إلى 8 أحرف.

ماذا يمكننا معرفته عن طلاب المادة من أسمائهم؟ لنأخذ أسم واحد منها:

```python
students['Name'][5]
```

```ruby
'jerry'
```

من هذا الإسم، يمكننا القول ان صاحب الأسم ذكر. ويمكننا التوقع ايضاً عمر الطالب. على سبيل المثال، اذا عرفنا أن اسم `Jerry` مشهور من بين أسماء الأطفال الذين ولدو في عام 1998، يمكننا التوقع أن عمر الطالب في العشرينيات.

التفكير بهذه الطريقة أوصلنا إلى سؤالين:

- هل يخبرنا أسم الطلاب عن توزيع الذكور والإناث؟
- هل يخبرنا أسم الطلاب عن توزيع الأعمار؟

للإجابه على هذه الأسئلة، سنحتاج بيانات تربط بين الأسماء مع الجنس والسنوات. مؤسسة الضمان الإجتماعي الأمريكية لديها مثل هذه البيانات ومتوفرة على الأنترنت على [الرابط](https://www.ssa.gov/oact/babynames/index.html).

سنبدأ أولاً بتحميل البيانات من الموقع ثم نقلها إلى بايثون. مرة أخرى، لا تقلق إذا لم تفهم الكود البرمجي في هذا الفصل، فقط ركز على فهم الخطوات بشكل عام:

```python
import urllib.request
import os.path

data_url = "https://www.ssa.gov/oact/babynames/names.zip"
local_filename = "babynames.zip"
if not os.path.exists(local_filename): # اذا توفرت البيانات، لا تحملها مرة أخرى
    with urllib.request.urlopen(data_url) as resp, open(local_filename, 'wb') as f:
        f.write(resp.read())
        
import zipfile
babynames = [] 
with zipfile.ZipFile(local_filename, "r") as zf:
    data_files = [f for f in zf.filelist if f.filename[-3:] == "txt"]
    def extract_year_from_filename(fn):
        return int(fn[3:7])
    for f in data_files:
        year = extract_year_from_filename(f.filename)
        with zf.open(f) as fp:
            df = pd.read_csv(fp, names=["Name", "Sex", "Count"])
            df["Year"] = year
            babynames.append(df)
babynames = pd.concat(babynames)
babynames
```

|**Year**|**Count**|**Sex**|**Name**||
:-----:|:-----:|:-----:|:-----:|:-----:
|1884|9217|F|Mary|0|
|1884|3860|F|Anna|1|
|1884|2587|F|Emma|2|
|...|...|...|
|1883|5|M|Verna|2081|
|1883|5|M|Winnie|2082|
|1883|5|M|Winthrop|2083|

```center-result
1891894 rows × 4 columns
```

البيانات تحتوي على الأسماء، جنس الطفل، عدد الأطفال بهذا الأسم وسنة ميلادهم. للتأكيد لنقرأ ما كتبة مكتب الضمان الإجتماعي في شرحهم للبيانات ([الرابط](https://www.ssa.gov/oact/babynames/background.html)).

> جميع الأسماء أتت من بطاقات التقديم للضمان الإجتماعي لجميع الولادات التي كانت في الولايات المتحدة بعد 1879. ملاحظة ان الكثير مِن مَن ولدو قبل 1937 لم يقدمو للحصول على البطاقة، لذا أسمائهم ليست ضمن البيانات. الآخرين الذين قدموا طلباتهم، بياناتنا قد لا تبين مكان ولادتهم، لذا أسمائهم لم تضاف للبيانات.
> هذي عينة كاملة من البيانات لدينا حتى تاريخ مارس 2017.

نبدأ أولاً بعرض عدد المواليد الذكور والإناث كل سنة

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter1/YearVsSex.jpg'>
</p>

الزيادة المفائجة بعدد المواليد في عام 1920 تبدو مشبوهه، ولكن في الإقتباس السابق وضح لنا السبب:

> ملاحظة ان الكثير مِن مَن ولدو قبل 1937 لم يقدمو للحصول على البطاقة، لذا أسمائهم ليست ضمن البيانات. الآخرين الذين قدموا طلباتهم، بياناتنا قد لا تبين مكان ولادتهم، لذا أسمائهم لم تضاف للبيانات.

يمكن ملاحظة فترة الإنجاب المتزايدة أو ما يسمونها Baby boomers والتي كانت في الفتره بين 1946 حتى 1964، للمزيد عن هذا الموضوع [هنا](https://www.wikiwand.com/en/Baby_boomers).


### معرفة الجنس من الأسم

لنستخدم بيانات الأطفال السابقة لمعرفة عدد الذكور والإناث في بياناتنا. كما فعلنا في بياناتنا السابقاً، نبدأ أولا بتصغير جميع أحرف الأسماء في بيانات الأطفال:

```python
babynames['Name'] = babynames['Name'].str.lower()
babynames
```

|**Year**|**Count**|**Sex**|**Name**||
:-----:|:-----:|:-----:|:-----:|:-----:
|1884|9217|F|mary|0|
|1884|3860|F|anna|1|
|1884|2587|F|emma|2|
|...|...|...|
|1883|5|M|verna|2081|
|1883|5|M|winnie|2082|
|1883|5|M|winthrop|2083|

```center-result
2084 rows × 4 columns
```

ثم نجمع عدد المواليد لكل أسم ونوع المولود:

```python
sex_counts = pd.pivot_table(babynames, index='Name', columns='Sex',
                            values='Count', aggfunc='sum',
                            fill_value=0., margins=True)
sex_counts
```

|**All**|**M**|**F**|**Sex**|
:-----:|:-----:|:-----:|:-----:|
| | | |Name|
|96|96|0|aaban|
|35|0|35|aabha|
|10|10|0|aabid|
|...|...|...|
|6|6|0|zyyon|
|5|5|0|zzyzx|
|344533897|173894326|170639571|All|

```center-result
96175 rows × 3 columns
```

لمعرفه نسبة شهرة الأسم أكثر في الذكور أو الإناث، يمكننا إيجاب نسبة تكرار هذا الأسم لدى الإناث:

```python
prop_female = sex_counts['F'] / sex_counts['All']
sex_counts['prop_female'] = prop_female
sex_counts
```

|**prop_female**|**All**|**M**|**F**|**Sex**|
:-----:|:-----:|:-----:|:-----:|
| | | | |Name|
|0.0|96|96|0|aaban|
|1.0|35|0|35|aabha|
|0.0|10|10|0|aabid|
|...|...|...|
|0.0|6|6|0|zyyon|
|0.0|5|5|0|zzyzx|
|0.5|344533897|173894326|170639571|All|

```center-result
96175 rows × 4 columns
```

يمكننا تعريف دالة لتبحث لنا عن ما إذا كان الأسم ذكراً او أنثى بإستخدام النسبة السابقة:

```python
def sex_from_name(name):
    if name in sex_counts.index:
        prop = sex_counts.loc[name, 'prop_female']
        return 'F' if prop > 0.5 else 'M'
    else:
        return 'Name not in dataset'

sex_from_name('sam')
```

```ruby
'M'
```


بأستخدام الكود البرمجي السابق يمكنك تجربة اي إسم واستنتاج ما إذا كان نسبة تسميتة كذكر أكثر أم كأنثى.

الآن لنعود لبيانات الطلاب ونضيف عليها ما إذا كان الطالب ذكراً أو أنثى.

|**Sex**|**Name**|**Role**||
:-----:|:-----:|:-----:
|F|keeley|Student|0|
|M|john|Student|1|
|M|bryan|Student|2|
|...|...|...|
|M|ernesto|Waitlist Student|276|
|M|athan|Waitlist Student|277|
|M|michael|Waitlist Student|278|

```center-result
279 rows × 4 columns
```


الآن يمكننا بسهولة معرفة عدد الذكور والإناث بين طلابنا:

```python
students['sex'].value_counts()
```


```ruby
M                      144
F                       92
Name not in dataset     43
Name: Sex, dtype: int64
```


### إيجاد العمر من الأسم

بإستخدام نفس الطريقة السابقة يمكننا إيجاد توزيع العمر في فصلنا، بربط كل أسم مع متوسط الأعمار في البيانات:

```python
def avg_year(group):
    return np.average(group['Year'], weights=group['Count'])

avg_years = (
    babynames
    .groupby('Name')
    .apply(avg_year)
    .rename('avg_year')
    .to_frame()
)
avg_years
```

|**avg_year**|
:-----:|:-----:
| |Name|
|2012.57|aaban|
|2013.71|aabha|
|2009.50|aabid|
|...|...|
|2010.00|zyyanna|
|2014.00|zyyon|
|2010.00|zzyzx|

```center-result
96174 rows × 1 columns
```

بنفس الطريقة السابقة، يمكن ان نبحث عن أي اسم ونجد متوسط سنة الميلاد:

```python
students['year'] = students['Name'].apply(year_from_name)
students
```

|**Year**|**Sex**|**Name**|**Role**||
:-----:|:-----:|:-----:
|1998.15|F|keeley|Student|0|
|1951.08|M|john|Student|1|
|1983.57|M|bryan|Student|2|
|...|...|...|
|1981.44|M|ernesto|Waitlist Student|276|
|2004.40|M|athan|Waitlist Student|277|
|1971.18|M|michael|Waitlist Student|278|

```center-result
279 rows × 4 columns
```


الآن، يمكننا بسهولة عرض توزيع السنوات بين الطلاب:

```python
sns.distplot(students['year'].dropna());
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter1/StudentYears.jpg'>
</p>

ولعرض متوسط عامود السنة نقوم بالآتي:

```python
students['year'].mean()
```

```ruby
1983.846741800525
```


متوسط الأعمار لدينا هو 35 سنه (2018-1983)، تقريباً أكثر مرتين من العمر المتوقع للطلاب الجامعيين. لماذا تظهر لنا البيانات مرتفعه بهذا الشكل؟

كعالم بيانات، قد نصل لنتائج لا نتفق معها أو عكس توقعاتنا. التحدي الدائم الذي يواجهنا هو معرفة ما إذا كانت النتائج التي فاجئتنا كانت بسبب خطأ في أحدى الخطوات التي قمنا بها أو خطأ حقيقي في البيانات. بما أنه لا يوجد هناك طريقة سهله لضمان نتائج دقيقه، عالم البيانات يجب أن يكون لديه مبادئ وقواعد للتقليل من إيجاد نتائج خاطئة.

في هذه الحالة بالذات، التفسير الوحيد النتيجة الغير متوقعة التي ظهرت لنا هو أن الأسماء الأكثر شيوعاً تستخدم منذ سنوات عديدة. مثلاً الأسم `John` يعتبر من الأسماء الأكثر شيوعاً عبر التاريخ بناءاً على البيانات لدينا. يمكننا تأكيد ذلك بعرض رسم بياني بعدد الأطفال الذين تم تسميتهم `John` كل سنة:

```python
names = babynames.set_index('Name').sort_values('Year')
john = names.loc['john']
john[john['Sex'] == 'M'].plot('Year', 'Count')
plt.title('Frequency of "John"');
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter1/JohnOverTheYears.jpg'>
</p>

يبدو لنا أن متوسط السنة لا يعطي توقع دقيق لعمر الشخص. ولكن في بعض الحالات، الأسم الأول للشخص يساعدنا بذلك، على سبيل المثال عند التجربة على اسم `Kanye` تظهر لنا النتيجة التالية:

```python
names = babynames.set_index('Name').sort_values('Year')
kanye = names.loc['kanye']
kanye[kanye['Sex'] == 'M'].plot('Year', 'Count')
plt.title('Frequency of "Kanye"');
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter1/KANYE.jpg'>
</p>

### ملخص الفصل الأول

في هذا الفصل، قمنا بالمرور بشكل سريع على دورة حياة علم البيانات: تشكيل السؤال أو المشكلة، إيجاد وتنظيف البيانات، إستشكاف البيانات، التوقع والإستدلال. سنشرح بشكل مفصل عن كل دورة في الفصول القادمة.

النصف الأول من الكتاب (الفصل 1 حتى 9) ستغطي الثلاث خطوات الأولى لدورة حياة علم البيانات وتركز بشكل كبير على طريقة الحساب وإيجاد النتائج. النصف الثاني (الفصل 10 حتى 18) يستخدم التفكير الحسابي والإحصائي لتغطية مواضيع بناء النماذج، الإستدلال والتوقع.

بشكل عام، يسعى هذا الكتاب لتعريف القارئ بالمبادئ وتقنيات علم البيانات.
