---
title: التعامل مع النصوص
show_title: true
chapter_number: 8
chapter_text: الفصل الثامن
chapter_lessons: [[0, 'مقدمة'], [1, 'دوال النصوص في بايثون'], [2, 'التعابير النمطية RegEx'], [3, 'التعابير النمطية في بايثون وبانداز']]
chapter_sublessons: [
    [],
    ['دوال النصوص في بايثون', 'تنظيف البيانات النصيه', 'دوال النصوص', 'دوال النصوص في بانداز', 'ملخص دوال النصوص'],
    [['كتابة أوامر التعابير النمطية', 'حرفياً', 'رموز خاصه', 'المجموعات النصيه', 'عكس المجموعات النصيه', 'الحدود الرقمية', 'الإرساء', 'تجاهل الرموز الخاصه'], 'مرجع التعابير النمطية'],
    ['RE.SEARCH', 'RE.FINDALL', 'REGEX مجموعات', 'RE.SUB', 'RE.SPLIT', 'REGEX و بانداز']
]
layout: default
---

## مقدمة

الكثير من البيانات التي نواجهها في ملف CSV ليست أرقام بس نصوص موجوده في كُتب، ملفات، تدوينات، او تعليقات في الانترنت. كما في الكثير من انواع البيانات، هناك طرق مختلفه للتعامل مع النصوص وقد نحتاج لكتابة اكثر من كتاب لشرحها بشكل تفصيلي. في هذا الفصل، سنشرح جزء بسيط من هذه التقنيات والتي توفر لنا العديد من العمليات المفيده للعمل مع النصوص: معالجة نصوص بايثون و التعابير النمطية RegEx.

### دوال النصوص في بايثون

توفر لنا بايثون العدد من الدوال للتعامل مع النصوص. رغم بساطتها، تعد هذه الدوال من الأولويات في التعامل مع النصوص والتي جُمعت مع بعضها البعض لتكون دوال اكثر تعقيداً. سنقوم بشرح دوال بايثون للتعامل مع النصوص حسب كثرة الإستخدام في تنظيف البيانات النصيه.

#### تنظيف البيانات النصيه

تأتي البيانات عادةً من عدة مصادر وكل مصدر لديه طريقه مختلفه لترميز المعلومات. في المثال التالي، لدينا جدول يحتوي على الولايات الأمريكيه والمقاطعات التي تشملها وجدول آخر يحتوي على عدد سكان المقاطعه.

```python
state = pd.DataFrame({
    'County': [
        'De Witt County',
        'Lac qui Parle County',
        'Lewis and Clark County',
        'St John the Baptist Parish',
    ],
    'State': [
        'IL',
        'MN',
        'MT',
        'LA',
    ]
})
population = pd.DataFrame({
    'County': [
        'DeWitt  ',
        'Lac Qui Parle',
        'Lewis & Clark',
        'St. John the Baptist',
    ],
    'Population': [
        '16,798',
        '8,067',
        '55,716',
        '43,044',
    ]
})
```

**State**|**County**| 
:-----:|:-----:|:-----:
IL|De Witt County|0
MN|Lac qui Parle County|1
MT|Lewis and Clark County|2
LA|St John the Baptist Parish|3

<br>

**Population**|**County**| 
:-----:|:-----:|:-----:
16,798|DeWitt|0
8,067|Lac Qui Parle|1
55,716|Lewis & Clark|2
43,044|St. John the Baptist|3

بالطبع نريد جمع جدولي `state` و `population` معاً بإستخدام العامود `County`. للأسف، لا تتطابق أي من اسماء المقاطعات في الجدولين. هذا المثال يوضح عدد من المشاكل في البيانات النصيه وهي كالتالي:

- الكتابة بحروف كبيره / صغيره: `qui` و `Qui`.
- علامات ترقيم مختلفة: `St.` و `St`.
- عدم كتابة بعض الكلمات: مثلاً كلمتي `County`/`Parish` لم يتم كتابتها في جدول `population`.
- اضافة مسافات: `DeWitt` و `De Witt`.
- استخدام مُختلف للإختصارات: `&` و `and`.

#### دوال النصوص

دوال النصوص في بايثون تساعدنا بالبدء في حل هذه المشاكل. هذه الدوال مُعرّفه في جميع نسخ بايثون لذا لا نحتاج لإستخادم اي مكتبه أخرى. على الرغم انه مهم جداً لك شخصياً معرفة [جميع الدوال للتعامل مع النصوص](https://docs.python.org/3/library/stdtypes.html#string-methods)، قمنا بشرح بعض من اكثر الدوال استخداماً في الجدول التالي:

**الداله**|**الوصف**
:-----:|:-----:
str[x:y]| تقوم الداله بفصل النص `str` من `x` (تشمل الحرف) حتى `y` (لا تشمل الحرف). 
()str.lower| تنشئ نسخه من النص `str` بعد تحويل جميع الحروف فيه إلى حروف صغيره. 
str.replace(a, b)| تحويل جميع مرات ظهور النص/الحرف `a` في  `str` إلى النص/الحرف `b`. 
str.split(a)| تقوم الدالة بفصل النص `str` عند ظهور النص/الحرف `a`. 
()str.strip| تحذف الداله المسافات الفارغه في بداية ونهاية النص `str` 

قمنا بإختيار النص `St. John the Baptist` من جدولي `state` و `population` لتطبيق دوال النصوص بحذف الحروف الكبيره، علامات الترقيم، و التخصل من الكلمتين `county` و `parish`:

```python
john1 = state.loc[3, 'County']
john2 = population.loc[3, 'County']

(john1
 .lower()
 .strip()
 .replace(' parish', '')
 .replace(' county', '')
 .replace('&', 'and')
 .replace('.', '')
 .replace(' ', '')
)
```

```ruby
'stjohnthebaptist'
```

تطبيق نفس الدوال على `john2` يأكد لنا ان النصين مُتطابقان:

```python
(john2
 .lower()
 .strip()
 .replace(' parish', '')
 .replace(' county', '')
 .replace('&', 'and')
 .replace('.', '')
 .replace(' ', '')
)
```

```ruby
'stjohnthebaptist'
```

عند الوصول لنتيجة مُقنعه، نقوم بتعريف دالة بأسم `clean_county` والتي ستطبق مهام تنظيف المدخلات (المقاطعات):

```python
def clean_county(county):
    return (county
            .lower()
            .strip()
            .replace(' county', '')
            .replace(' parish', '')
            .replace('&', 'and')
            .replace(' ', '')
            .replace('.', ''))
```

يمكننا التأكد ان الداله `clean_county` تقوم بتوحيد جميع اسماء المقاطعات عبر تطبيقها على الجدولين:

```python
([clean_county(county) for county in state['County']],
 [clean_county(county) for county in population['County']]
)
```

```ruby
(['dewitt', 'lacquiparle', 'lewisandclark', 'stjohnthebaptist'],
 ['dewitt', 'lacquiparle', 'lewisandclark', 'stjohnthebaptist'])
```

بما ان كلا العامودين الآن يحتويان على نفس اسم المقاطعه وبنفس الشكل، يمكننا جمع الجدولين معاً بإستخدام اسم المقاطعه.

#### دوال النصوص في بانداز

في الكود البرمجي السابق، استخدمنا التكرار Loop لتغير أسامي المقاطعات. مصفوفات `pandas` تقدم طريقة اسهل لتطبيق دوال النصوص لجميع محتوى المصفوفه. اولاً، لنرى اسماء المقاطعات في جدول `state`:

```python
state['County']
```

```ruby
0                De Witt County
1          Lac qui Parle County
2        Lewis and Clark County
3    St John the Baptist Parish
Name: County, dtype: object
```

الدالة `.str` في مصفوفات بانداز تتعامل مع النص كما في بايثون. استخدام الدوال على `.str` يطبقها على جميع القيم في المصفوفه:

```python
state['County'].str.lower()
```

```ruby
0                de witt county
1          lac qui parle county
2        lewis and clark county
3    st john the baptist parish
Name: County, dtype: object
```

يُمكنا ذلك من تحويل جميع النصوص في المصفوفه دون الحاجه لإستخدام التكرار:

```python
(state['County']
 .str.lower()
 .str.strip()
 .str.replace(' parish', '')
 .str.replace(' county', '')
 .str.replace('&', 'and')
 .str.replace('.', '')
 .str.replace(' ', '')
)
```

```ruby
0              dewitt
1         lacquiparle
2       lewisandclark
3    stjohnthebaptist
Name: County, dtype: object
```

نعيد حفظ نتيجة تغير شكل عامود المقاطعات على نفس العامود:

```python
state['County'] = (state['County']
 .str.lower()
 .str.strip()
 .str.replace(' parish', '')
 .str.replace(' county', '')
 .str.replace('&', 'and')
 .str.replace('.', '')
 .str.replace(' ', '')
)

population['County'] = (population['County']
 .str.lower()
 .str.strip()
 .str.replace(' parish', '')
 .str.replace(' county', '')
 .str.replace('&', 'and')
 .str.replace('.', '')
 .str.replace(' ', '')
)
```

والآن بما ان كلا الجدولين لديهما نفس التعبير النصي للمقاطعات:

```python
state
```

**State**|**County**| 
:-----:|:-----:|:-----:
IL|dewitt|0
MN|lacquiparle|1
MT|lewisandclark|2
LA|stjohnthebaptist|3

```python
population
```

**Population**|**County**| 
:-----:|:-----:|:-----:
16,798|dewitt|0
8,067|lacquiparle|1
55,716|lewisandclark|2
43,044|stjohnthebaptist|3

من السهل جمع الجدولين عندما يتطابق عامود المناطق:

```python
state.merge(population, on='County')
```

**Population**|**State**|**County**| 
:-----:|:-----:|:-----:|:-----:
16,798|IL|dewitt|0
8,067|MN|lacquiparle|1
55,716|MT|lewisandclark|2
43,044|LA|stjohnthebaptist|3

#### ملخص دوال النصوص

توفر بايثون دوال سهله وعمليه للتعامل وتعديل النصوص. مصفوفات بانداز توفر نفس الدوال وتسهل تطبيقها على جميع القيم داخل المصفوفه.

يمكنك تصفح شرح كامل عن دوال النصوص في بايثون [هنا](https://docs.python.org/3/library/stdtypes.html#string-methods) ودوال النصوص في بانداز [هنا](https://pandas.pydata.org/pandas-docs/stable/text.html#method-summary)

### التعابير النمطية RegEx

في هذا الجزء سنتحدث عن التعابير النمطية RegEx، اداة مهمه للتحقق من الأنماط في النصوص.

في النصوص الكبيره، الكثير من النصوص الفرعيه تأتي بعدة اشكال. مثلاً، الجمله في الأسفل تحتوي على رقم هاتف:

```ruby
"give me a call, my number is 123-456-7890."
```

رقم الهاتف يحتوي على الأنماط التاليه:
- ثلاث ارقام.
- متبوعه بخط فاصل.
- متبوعه بثلاث ارقام.
- متبوعه بخط فاصل.
- متبوعه بأربع ارقام.

اذا اعطينا نصاً مكتوب، قد نرغب بإيجاد وسحب ارقام الهواتف فقط. ربماً ايضاً نريد جزء معين من رقم الهاتف، مثلاً، سحب رمز المنطقة (الثلاث ارقام الأولى) قد يوصل لنا مكان تواجد صاحب الرقم المذكور في النص.

للتحقق اذا كان النص يحتوي على رقم هاتف، قد نعرف دالة كالتالي:

```python
def is_phone_number(string):
    
    digits = '0123456789'
    
    def is_not_digit(token):
        return token not in digits 
    
    # ثلاث ارقام
    for i in range(3):
        if is_not_digit(string[i]):
            return False
    
    # متبوعه بخط فاصل
    if string[3] != '-':
        return False
    
    # متبوعه بثلاث ارقام
    for i in range(4, 7):
        if is_not_digit(string[i]):
            return False
        
    # متبوعه بخط فاصل   
    if string[7] != '-':
        return False
    
    # متبوعه بأربع ارقام
    for i in range(8, 12):
        if is_not_digit(string[i]):
            return False
    
    return True
```

وللتحقق:

```python
is_phone_number("382-384-3840")
```

```ruby
True
```

```python
is_phone_number("phone number")
```

```ruby
False
```

الكود العلوي يبدو طويل وغير مرغوب فيه. بدلاً من الدوران على كل الحروف في النص، نفضل ان نحدد النمط واوامر لبايثون تسهل علينا إيجاد الأنماط المطابقه لطلباتنا.

**التعابير النمطية Regular expressions** (وبشكل مختصر **RegEx**) تحل هذه المشكلة بجعلنا ننشأ الأنماط للنصوص. بإستخدامها، يمكننا اعادة تعريف الدالة السابقة `is_phone_number` بسطرين في بايثون:

```python
import re

def is_phone_number(string):
    regex = r"[0-9]{3}-[0-9]{3}-[0-9]{4}"
    return re.search(regex, string) is not None

is_phone_number("382-384-3840")
```

```ruby
True
```

في المثال السابق، استخدمنا التعبير النمطي `[0-9]{3}-[0-9]{3}-[0-9]{4}` لمطابقة أرقام الهواتف. ربما يبدو مبهماً في البداية، ولكن أوامر التعابير النمطية سهلة للتعلم؛ في هذا الفصل شرحنا كل الأوامر.

سنقوم بالتعرف على المكتبه التي تأتي مع بايثون بأسم `re` الخاصه بكتابة وتطبيق عمليات النصوص بإستخدام التعابير النمطية.

#### كتابة أوامر التعابير النمطية

سنبدأ أولاً بالتعرف على طريقة الكتابه. التعابير النمطية عادةً ما تُحفظ على شكل نصوص خام Raw String. تعمل تماماً كما تعمل النصوص في بايثون ولكن بدون قوانين خاصه للخطوط المائله.

مثلاً لحفظ النص `hello \ world` في بايثون، نحتاج لكتابة:

```python
# الخطوط المائلة في بايثون تحتاج للتوضيح ليتم تجاهلها في نصوص بايثون العاديه
some_string = 'hello \\ world'
print(some_string)
```

```ruby
hello \ world
```

إستخدام النصوص الخامه يحذف شرط اضافة رمز لتجاهل الخطوط المائله:

```python
# لاحظ ال `r` قبل بداية النص
some_raw_string = r'hello \ world'
print(some_raw_string)
```

```ruby
hello \ world
```

بما ان الخطوط المائلة تظهر بشكل كثير في التعابير النمطية، سنستخدم النصوص الخامه لكتابة جميع التعابير النمطية في هذا القسم.

#### حرفياً

ايجاد حرف بشكل معين بالتحديد في التعبر النمطي يوجد لنا ذلك الحرف فقط. مثلاً، التعبير `r"a"` يوجد لنا أي `"a"` في `"Say! I like green eggs and ham!"`. جميع الأرقام والأحرف ورموز الترقيم يمكن البحث عنها بشكل خاص في التعابير النمطية:

```python
def show_regex_match(text, regex):
    """
    تطبع النص مع تغير اللون لتحديد نمط regex
    """
    print(re.sub(f'({regex})', r'\033[1;30;43m\1\033[m', text))
```

```python
regex = r"green"
show_regex_match("Say! I like green eggs and ham!", regex)
```

<div class="regex">
<pre class="highlight">
Say! I like <span>green</span> eggs and ham!
</pre>
</div>

```python
show_regex_match("Say! I like green eggs and ham!", r"a")
```

<div class="regex">
<pre class="highlight">
S<span>a</span>y! I like green eggs <span>a</span>nd h<span>a</span>m!
</pre>
</div>

في المثال السابق، شاهدنا ان التعابير النمطية يمكنها إيجاد الانماط اينما ظهر في النص المدخل. في بايثون، في بايثون هذه الطريقة تختلف بناءًا على الدالة المدخله لمطابقة التعبير النمطي، بعض الدوال فقط تظهر النتيجه اذا ظهر في بداية النص، والبعض يظهرها اذا ظهرت في اي مكان في النص.

لاحظ ايضاً ان الدالة `show_regex_match` تظهر جميع تكرارات النمط في النص المدخل. مره أخرى، يختلف ذلك حسب دالة بايثون المستخدمه، بعضها يظهر جميع التكرارات والبعض فقط يظهر اول تكرار.

التعابير النمطية تتحسس لحالة وشكل الحرف. في المثال التالي، التعبير يطابق فقط الحرف الصغير `s` في `eggs`، وليس الحرف الكبير `S` في `Say`.

```python
show_regex_match("Say! I like green eggs and ham!", r"s")
```

<div class="regex">
<pre class="highlight">
Say! I like green egg<span>s</span> and ham!
</pre>
</div>

#### رموز خاصه

بعض الرموز لديها معاني خاصه في RegEx. هذه الرموز تساعدنا على إيجاد انماط مختلفه من النصوص.

الرمز `.` (نقطة) تعني انه تطابق أي حرف عدى ان يكون ببداية سطر جديد:

```python
show_regex_match("Call me at 382-384-3840.", r".all")
```

<div class="regex">
<pre class="highlight">
<span>Call</span> me at 382-384-3840.
</pre>
</div>

لنطابق النقطة بشكل خاص يجب علينا تجاهلها كرمز بإضافة `\`:

```python
show_regex_match("Call me at 382-384-3840.", r"\.")
```

<div class="regex">
<pre class="highlight">
Call me at 382-384-3840<span>.</span>
</pre>
</div>

بإستخدام النقطه يمكننا مطابقة انواع مختلفة من الأنماط، سنقوم بكتابة تعبير نمطي لمطابقة ارقام الهواتف. مثلاً، يمككنا اخذ الرقم `382-384-3840` وتبديل كل رقم بنقطة `.`، لتبقى لنا فقط الخطوط الفاصله. النتيجه كالتالي `...-...-....`:

```python
show_regex_match("Call me at 382-384-3840.", "...-...-....")
```

<div class="regex">
<pre class="highlight">
Call me at <span>382-384-3840</span>.
</pre>
</div>

بما ان النقطة تطابق جميع النصوص، النص التالي سيظهر لنا نتيجة خاطئة:

```python
show_regex_match("My truck is not-all-blue.", "...-...-....")
```

<div class="regex">
<pre class="highlight">
My truck is <span>not-all-blue</span>.
</pre>
</div>

#### المجموعات النصيه

تسمح لنا المجموعات النصيه بمطابقة نوع معين من النصوص، يوفر لنا ذلك امكانية انشاء قيود للتطابق بدلاً من `.` لمطابقة اي نص. لإنشاء مجموعة، قم بإضافتها داخل اقواس `[ ]`:

```python
show_regex_match("I like your gray shirt.", "gr[ae]y")
```

<div class="regex">
<pre class="highlight">
I like your <span>gray</span> shirt.
</pre>
</div>

```python
show_regex_match("I like your grey shirt.", "gr[ae]y")
```

<div class="regex">
<pre class="highlight">
I like your <span>grey</span> shirt.
</pre>
</div>

```python
# لا يطابق، المجموعات تطابق حرف واحد فقط من ما تحتويها وليس جميعها
show_regex_match("I like your graey shirt.", "gr[ae]y")
```

<div class="regex">
<pre class="highlight">
I like your graey shirt.
</pre>
</div>

```python
# في هذا المثال، كتابة المجموعه مره اخرى ستطابقها
show_regex_match("I like your graey shirt.", "gr[ae][ae]y")
```

<div class="regex">
<pre class="highlight">
I like your <span>graey</span> shirt.
</pre>
</div>

في مجموعات النصوص، الرمز `.` سيتخدم كحرف وليس كرمز:

```python
show_regex_match("I like your grey shirt.", "irt[.]")
```

<div class="regex">
<pre class="highlight">
I like your grey sh<span>irt.</span>
</pre>
</div>

توجد بعض الحالات المختصره الخاصه التي يمكن استخدامها لمطابقة مجموعات النصوص:

**الإختصار**|**المعنى**
:-----:|:-----:
[0-9]|جميع الارقام
[a-z]|الأحرف الصغيره
[A-Z]|الأحرف الكبيره

<br>

```python
show_regex_match("I like your gray shirt.", "y[a-z]y")
```

```ruby
I like your gray shirt.
```

تُمكنا المجموعات النصيه من انشاء انماط خاصه بأرقام الهواتف:

```python
# استبدلنا النقاط `.` في ...-...-.... ب [0-9] لتحديد النمط على الأرقام
phone_regex = r'[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]'
show_regex_match("Call me at 382-384-3840.", phone_regex)
```

<div class="regex">
<pre class="highlight">
Call me at <span>382-384-3840</span>.
</pre>
</div>

```python
# والآن لا نطابق هذا النص
show_regex_match("My truck is not-all-blue.", phone_regex)
```

```ruby
My truck is not-all-blue.
```

#### عكس المجموعات النصيه

عكس المجموعات يطابق اي نص غير الموجود في المجموعه. لإنشاء هذا التعبير، نضيف النص داخل الأقواس `[^ ]`:

```python
show_regex_match("The car parked in the garage.", r"[^c]ar")
```

<div class="regex">
<pre class="highlight">
The car <span>par</span>ked in the <span>gar</span>age.
</pre>
</div>

#### الحدود الرقمية

لإنشاء تعبير نمطي لمطابقة ارقام الهواتف، كتبنا التالي:

```python
[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]
```

هذا النمط يطابق 3 ارقام، متبوعه بخط، ثم ثلاث ارقام وخط ثم اربع ارقام اخرى.

الحدود الرقميه تسمح لنا مطابقة التكرار في النمط. نحدد عدد مرات التكرار بوضع الرقم داخل اقواس معقوفة `{ }`:

```python
phone_regex = r'[0-9]{3}-[0-9]{3}-[0-9]{4}'
show_regex_match("Call me at 382-384-3840.", phone_regex)
```

<div class="regex">
<pre class="highlight">
Call me at <span>382-384-3840</span>.
</pre>
</div>

```python
# لا تطابق لأن اول جزء مكون من رقمين
phone_regex = r'[0-9]{3}-[0-9]{3}-[0-9]{4}'
show_regex_match("Call me at 12-384-3840.", phone_regex)
```

```ruby
Call me at 12-384-3840.
```

الحدود تطابق جميع النصوص او الفئات النصيه التي كُتبت قبلها. الجدول التالي يظهر شرح لها:

**رمز الحدود الرقميه**|**المعنى**
:-----:|:-----:
{m, n}|مطابقة تكرار النص من m إلى n مرات.
{m}|مطابقة تكرار النص m مرات.
{m,}|مطابقة تكرار النص على الأقل m مرات.
{,n}|مطابقة تكرار النص بالأكثر n مرات.

##### اختصارات الحدود الرقمية

الكثير من الحدود الرقمية التي تستخدم كثيراً تم اختصارها:

**الرمز**|**رمز الحدود الرقمية المفصل**|**المعنى**
:-----:|:-----:|:-----:
*|{0,}|مطابقة تكرار النص 0 أو أكثر.
+|{1,}|مطابقة تكرار النص مره واحده أو أكثر.
?|{0,1}|مطابقة تكرار النص 0 أو مره واحده.

نستخدم الرمز `*` بدلاً من `{0,}` في الأمثلة التاليه:

```python
# تكرار a ثلاث مررات
show_regex_match('He screamed "Aaaah!" as the cart took a plunge.', "Aa*h!")
```

<div class="regex">
<pre class="highlight">
He screamed "<span>Aaaah!</span>" as the cart took a plunge.
</pre>
</div>

```python
# مطابقة المزيد من a
show_regex_match(
    'He screamed "Aaaaaaaaaaaaaaaaaaaah!" as the cart took a plunge.',
    "Aa*h!"
)
```

<div class="regex">
<pre class="highlight">
He screamed "<span>Aaaaaaaaaaaaaaaaaaaah!</span>" as the cart took a plunge.
</pre>
</div>

```python
# عدم وجود a بشكل صغير
show_regex_match('He screamed "Ah!" as the cart took a plunge.', "Aa*h!")
```

<div class="regex">
<pre class="highlight">
He screamed "<span>Ah!</span>" as the cart took a plunge.
</pre>
</div>

##### الحدود الكمية جشعه!

توجد لنا دائماً الحدود الكمية أكثر القيم تطابقاً. تظهر بعض المرات نتائج غير متوقعه:

```python
# حاولنا إيجاد 311 و 911 ولكن تم ايجاد and ايضاً
# لأن
# <311> and <911>
# هي اعلى قيمه ممكنه للنمط <.+>
show_regex_match("Remember the numbers <311> and <911>", "<.+>")
```

<div class="regex">
<pre class="highlight">
Remember the numbers <span><311> and <911></span>
</pre>
</div>

في كثير من الحالات، استخدام مجموعات النصوص يسهل علينا تفادي هذه النتائج الخاطئه:

```python
show_regex_match("Remember the numbers <311> and <911>", "<[0-9]+>")
```

<div class="regex">
<pre class="highlight">
Remember the numbers <span><311></span> and <span><911></span>
</pre>
</div>


#### الإرساء

#### تجاهل الرموز الخاصه

### مرجع التعابير النمطية

### التعابير النمطية في بايثون وبانداز

#### RE.SEARCH

#### RE.FINDALL

#### REGEX مجموعات

#### RE.SUB

#### RE.SPLIT

#### REGEX و بانداز




[📝][HTTPStatusCodes]

[HTTPStatusCodes]: https://www.restapitutorial.com/httpstatuscodes.html