---
title: قواعد البيانات العلائقيه و SQL
show_title: true
chapter_number: 9
chapter_text: الفصل التاسع
chapter_lessons: [[0, 'مقدمة'], [1, 'النموذج العلائقي'], [2, 'SQL'], [3, 'الربط في SQL']]
chapter_sublessons: [
    [],
    ['انظمة قواعد البيانات العلائقيه', 'RDBMS × بانداز'],
    ['تنفيذ اوامر الاستعلام في بانداز' , ['طريقة كتابة اوامر SQL', 'SELECT و FROM', 'WHERE', 'دوال الجمع', 'GROUP BY و HAVING', 'ORDER BY و LIMIT', 'ترتيب الأوامر في SQL'], 'ملخص SQL'],
    ['الربط', ['Join', 'Inner Join', 'Full/Outer Join', 'Left Join', 'Right Join', 'Implicit Inner Join'], 'ربط أكثر من جدول', 'ملخص الربط']
]
layout: default
---

## مقدمة

حتى الآن، قمنا بالتعامل مع بيانات محفوظه في ملفات نصيه على الكمبيوتر. على الرغم من سهولة التعامل مع البيانات ذات الحجم الصغير في التحليل، إلا ان استخدام الملفات النصيه لحفظها يظهر لنا بعض التحديات في حالات كثيره عندما نعمل على بيانات حقيقه.

الكثير من البيانات تم جمعها من قبل أشخاص متعددين، فريق من علماء البيانات مثلاً. اذا تم حفظ البيانات في ملفات نصيه، سيحتاج الفريق لتحميل وارسال البيانات في كل مره يتم التعديل عليها. الملفات النصيه لا توفر طريقة مناسبه لإستعادة ليتم استخدامها بين عدد مختلف من المحللين. هذه المشكله، اضافة إلى مشاكل أخرى، تصعب عمل الملفات النصيه لفريق التحليل او اذا كان حجم البيانات كبيراً.

عادةً ما ننتقل لأنظمة قواعد البيانات العلائقيه (RDBMS) لحفظ البيانات، مثلاً MySQL او PostgreSQL. للعمل على هذه الأنظمة، نستخدم لغة الإستعلام SQL بدلاً من بايثون. في هذا الفصل، سنتحدث عن قواعد البيانات العلائقيه ونتعرف على SQL.

## النموذج العلائقي

**قاعدة البيانات** هي مجموعة مُرتبه من البيانات. في السابق، كانت البيانات محفوظه ومصممه بشكل معين لتفي بغرض ما. مثلاً، شركة طيران قد تقوم بحفظ معلومات رحلة بطريقه مختلفه عن حفظ بنك لمعلومات حساب. في عام 1969، قام تيد كود Ted Codd بتعريف النموذج العلائقي كطريقه عامه لحفظ البيانات. البيانات محفوظه في جداول ثنائية الأبعاد تسمى **علاقات Relations**، تحتوي على ملاحظات معينة في كل صف (عادة ما تعرف بمصفوفات Tuples). كل مصفوفه تحتوي على بعض **السمات Attributes** والتي تصف العلاقات بين الجداول. كل سمه عن علاقه لديها اسم ونوع.

لنأخذ جدول العلاقات التالي `purchases`:

**name**|**product**|**retailer**|**date purchased**
:-----:|:-----:|:-----:|:-----:
Samantha|iPod|Best Buy|03-Jun-16
Timothy|Chromebook|Amazon|08-Jul-16
Jason|Surface Pro|Target|02-Oct-16

في `purchases`، كل صف يصف علاقه بين السمات `name`، `product`، `retailer` و `date purchased`.

*مخطط العلاقات Relation schema* تحتوي على أسماء العواميد، انواع البيانات وقيودها. مثلاً، مخطط جدول `purchases` يحدد ان هناك العواميد `name`، `product`، `retailer` و `date purchased`، ويوضح أيضاً ان كل عامود يحتوي على نص.

جدول العلاقات التالي `prices` يوضح السعر الحالي لمنتجات في اسواق مختلفه:

**retailer**|**product**|**price**
:-----:|:-----:|:-----:
Best Buy|Galaxy S9|719.00
Best Buy|iPod|200.00
Amazon|iPad|450.00
Amazon|Battery pack|24.87
Amazon|Chromebook|249.99
Target|iPod|215.00
Target|Surface Pro|799.00
Target|Google Pixel 2|659.00
Walmart|Chromebook|238.79

الآن يمكننا العودة لكلا الجدولين لتحديد كم دفع كل من Samantha، Timothy، و Jason لمنتجاتهم (لنفترض بقاء الأسعار كما هي في جميع الأسواق والأوقات). معاً، كلا الجدولين يكونا **قاعدة بيانات علائقيه**، والتي هي عباره عن جداول بينها أكثر من علاقه. المخطط لكامل قاعدة البيانات هي مصفوفه تحتوي على جميع مخططات العلاقات في قاعدة البيانات.

### انظمة قواعد البيانات العلائقيه

يمكننا وصف قواعد البيانات العلائقيه بأنها مجموعه من الجداول تحتوي على صفوف لمدخلات. نظام قاعدة بيانات علائقيه (RDBMS) يوفر واجهه للمستخدم لتلك القواعد. [Oracle](https://www.wikiwand.com/en/Oracle_Database)، [MySQL](https://www.wikiwand.com/en/MySQL) و [PostgreSQL](https://www.wikiwand.com/en/PostgreSQL) هي ثلاث من أكثر قواعد البيانات العلائقيه إستخداماً.

توفر هذه الأنظمة المستخدم امكانية إضافة، تعديل، وحذف البيانات منها. إضافة لعدد من المميزات لتميزها عن إستخدام الملفات النصيه لحفظ البيانات، وهي:

- ضمانية حفظ البيانات: تحمي هذه الأنظمة البيانات من مشاكل الأنظمة المختلفه.
- الأداء: تحفظ البيانات بشكل أكثر كفاءة من الملفات النصيه ولديها خوارزميات صُممت بشكل متقن للإستعلام عن البيانات.
- إدارة البيانات: توفر ادوات للتحكم بالوصول للبيانات، للحمايه من المستخدمين غير المصرح لهم بالوصول للبيانات الحساسه.
- تناسق البيانات: يمكن لهذه الأنظمة فرض قيود على المحتوى المُدخل، مثلاً، العامود `GPA` يجب ان يحتوي فقط على رقم عشري من 0.0 حتى 4.0.

للتعامل مع البيانات المحفوظه فيه قواعد RDBMS نستخدم SQL.

### RDBMS × بانداز

ما الفرق بين RDBMS و بانداز؟ أولاً، بانداز لا تعتبر وسيله لحفظ البيانات. على الرغم ان ال DataFrames في بانداز يمكنها الكتابه والقراءة من عدة اشكال للبيانات، لا يمكن لبانداز التحكم بطريقة حفظ البيانات في الكمبيوتر كما في RDBMS. ثانياً، بانداز توفر بشكل اساسي ادوات للتعامل مع البيانات، بينما RDBMS توفر طرق حفظ والتعامل مع البيانات معاً، مما يجعلها خياراً افضل للبيانات ذات الحجم الكبير. من القواعد العامه هي ان نستخدم RDBMS عندنا تكون حجم البيانات لدينا أكثر من عدة قيقا بايت. اخيراً، للتعامل مع بانداز نحتاج لمعرفة ببايثون، بينما في RDBMS نحتاج لمعرفة SQL. وبما ان SQL اسهل بكثير للتعلم من بايثون، مما يجعل RDBMS سهله للتعامل من قبل المستخدمين غير التقنيين.


## SQL

SQL (لغة الاستعلام الهيكلية) هي لغه برمجه لديها عمليات لتحديد، ترتيب، تعديل و إجراء العمليات الحسابيه على بيانات محفوظه في انظمة قواعد البيانات العلائقيه (RDBMS).

تعتبر SQL لغة برمجه تعريفيه. يعني ذلك ان المستخدم يجب ان يحدد اي نوع من البيانات يحتاج *what*، وليس كيف يحصل عليه *how*. للتوضيح:

- **Declarative تعرفيه**: قم بعملية حساب للعامودين `x` و `y` من الجدول `A` عندما تكون القيمة في العامود `y` أكبر من 100.00.
- **Imperative أمريه**: لكل قيمه في الجدول `A`، تحقق أن كانت القيمه للمتغير `y` أكثر من 100. إذا كانت كذلك، احفظ سمات العواميد `x` و `y` في جدول جديد. واظهر لنا الجدول الجديد.

في هذا الفصل، سنكتب استعلامات SQL كنصوص في بايثون، ثم نستخدم بانداز لتنفيذ هذه أوامر الإستعلام وقراءة النتائج ك DataFrame في بانداز. اثناء شرحنا للأوامر في SQL، سنظهر طريقة كتابتها في بانداز للمقارنه بينهما.

### تنفيذ اوامر الاستعلام في بانداز

لتنفيذ اوامر استعلام SQL في بايثون، سنقوم بالتواصل مع قاعدة البيانات بإستخدام مكتبة [sqlalchemy](http://docs.sqlalchemy.org/en/latest/core/tutorial.html). يمكننا لاحقاً إستخدام الدالة [pd.read_sql](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql.html) لتنفيذ اوامر SQL.

> لتحميل قاعدة البيانات sql_basics.db [اضغط هنا]({{ site.baseurl }}/files/chapter9/sql_basics.db).

```python
import sqlalchemy

# pd.read_sql يقبل متغير engine يوصلنا بقاعدة البيانات، والذي انشأناه بالأسفل
sqlite_uri = "sqlite:///sql_basics.db"
sqlite_engine = sqlalchemy.create_engine(sqlite_uri)
```

تحتوي قاعدة البيانات على جدول علاقات واحد: `prices`. لإظهاره نستخدم امر استعلام في SQL بإستخدام الداله `read_sql` على قاعدة البيانات العلائقية RDBMS، ثم تأتينا النتيجة ك DataFrame:

```python
sql_expr = """
SELECT * 
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

**price**|**product**|**retailer**| 
:-----:|:-----:|:-----:|:-----:
719|Galaxy S9|Best Buy|0
200|iPod|Best Buy|1
450|iPad|Amazon|2
24.87|Battery pack|Amazon|3
249.99|Chromebook|Amazon|4
215|iPod|Target|5
799|Surface Pro|Target|6
659|Google Pixel 2|Target|7
238.79|Chromebook|Walmart|8

لاحقاً في هذا الفصل، سنقارن بين استعلامات SQL و دوال بانداز لذا قمنا بكتابة DataFrame تحتوي على نفس المحتوى السابق وحفظناها في المتغير `prices`:

```python
import pandas as pd

prices = pd.DataFrame([['Best Buy', 'Galaxy S9', 719.00],
                   ['Best Buy', 'iPod', 200.00],
                   ['Amazon', 'iPad', 450.00],
                   ['Amazon', 'Battery pack', 24.87],
                   ['Amazon', 'Chromebook', 249.99],
                   ['Target', 'iPod', 215.00],
                   ['Target', 'Surface Pro', 799.00],
                   ['Target', 'Google Pixel 2', 659.00],
                   ['Walmart', 'Chromebook', 238.79]],
                 columns=['retailer', 'product', 'price'])
```

**price**|**product**|**retailer**| 
:-----:|:-----:|:-----:|:-----:
719|Galaxy S9|Best Buy|0
200|iPod|Best Buy|1
450|iPad|Amazon|2
24.87|Battery pack|Amazon|3
249.99|Chromebook|Amazon|4
215|iPod|Target|5
799|Surface Pro|Target|6
659|Google Pixel 2|Target|7
238.79|Chromebook|Walmart|8

### طريقة كتابة اوامر SQL

جميع اوامر الإستعلام في SQL تكون بهذا الشكل:

```python
SELECT [DISTINCT] <column expression list>
FROM <relation>
[WHERE <predicate>]
[GROUP BY <column list>]
[HAVING <predicate>]
[ORDER BY <column list>]
[LIMIT <number>]
```

لاحظ ان:
- **جميع ما في [داخل الأقواس] هي اوامر إختياريه.** ليكون امر الاستعلام صحيح يجب ان يحتوي على `SELECT` و `FROM`.
- **في العادة تكتب اوامر الأستعلام في SQL بأحرف إنجليزيه كبيره.** على الرغم ان تكبير الأحرف ليس مطلوب، لكن يعتبر من الطرق المتبعه الصحيحه لكتابة الأوامر، لتسهل على المستخدمين الآخرين قراءة استعلاماتك.
- في الأمر `FROM` يمكننا الاستعلام عن اكثر من جدول، ولكن في هذا الفصل سنتدرب على استخدام جدول واحد لجعل الأمر سهلاً على المتعلم.

#### SELECT و FROM

الأمران الألزاميان في استعلامات SQL هي:

- `SELECT` وتعني العواميد التي نريد اظهارها.
- `FROM` ويقصد بها الجداول التي نأخذ منها العواميد.

لعرض جميع محتوى جدول `prices`، نطبق الأمر:

```python
sql_expr = """
SELECT * 
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

**price**|**product**|**retailer**| 
:-----:|:-----:|:-----:|:-----:
719|Galaxy S9|Best Buy|0
200|iPod|Best Buy|1
450|iPad|Amazon|2
24.87|Battery pack|Amazon|3
249.99|Chromebook|Amazon|4
215|iPod|Target|5
799|Surface Pro|Target|6
659|Google Pixel 2|Target|7
238.79|Chromebook|Walmart|8

الأستعلام `SELECT *` يجلب لنا جميع العواميد. لعرض فقط عامود `retailer`، نقوم بإضافتها كالتالي:

```python
sql_expr = """
SELECT retailer
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

|**retailer**||
:-----:|:-----:|
|Best Buy|0
|Best Buy|1
|Amazon|2
|Amazon|3
|Amazon|4
|Target|5
|Target|6
|Target|7
|Walmart|8

اذا اردنا عرض القيم في الجدول بدون تكرار، نقوم بإضافة `DISTINCT`:

```python
sql_expr = """
SELECT DISTINCT(retailer)
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

|**retailer**||
:-----:|:-----:|
Best Buy|0
Amazon|1
Target|2
Walmart|3

طريقة كتابة هذا الإستعلام في بانداز تكون كالتالي:

```python
prices['retailer'].unique()
```

```ruby
array(['Best Buy', 'Amazon', 'Target', 'Walmart'], dtype=object)
```

كل نظام قواعد بيانات يأتي بدوالة الخاصه التي يمكن تطبيقها، مثلاً دوال مقارنه، العمليات الحسابيه، ودوال النصوص. في هذه الماده نستخدم PostgreSQL، نظام قواعد بيانات علائقي ويأتي معه بالكثير من الدوال. يمكن تصفح كامل الدوال [هنا](https://www.postgresql.org/docs/9.2/static/functions.html). تذكر دائماً ان كل نظام لديه دوالة الخاصه.

الإستعلام التالي يحول كل اسماء الأسواق إلى حروف كبيره، ويقوم بقسمة سعر الشراء على 2:

```python
sql_expr = """
SELECT
    UPPER(retailer) AS retailer_caps,
    product,
    price / 2 AS half_price
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

**half\_price**|**product**|**retailer\_caps**| 
:-----:|:-----:|:-----:|:-----:
359.5|Galaxy S9|BEST BUY|0
100|iPod|BEST BUY|1
225|iPad|AMAZON|2
12.435|Battery pack|AMAZON|3
124.995|Chromebook|AMAZON|4
107.5|iPod|TARGET|5
399.5|Surface Pro|TARGET|6
329.5|Google Pixel 2|TARGET|7
119.395|Chromebook|WALMART|8

لاحظ ان بإمكاننا استخدام مسميات مستعاره للجداول **Alias** بإستخدام `AS` لكي يظهر العامود بمسمى جديد. لكن هذا لا يغير شئ بإسم العامود الأصلي

#### WHERE

`WHERE` تُمكنا من تحديد شروط معينة للبيانات. مثلاً، اذا اردنا إيجاد فقط المنتجات اقل من $500:

```python
sql_expr = """
SELECT *
FROM prices
WHERE price < 500
"""
pd.read_sql(sql_expr, sqlite_engine)
```

**price**|**product**|**retailer**| 
:-----:|:-----:|:-----:|:-----:
200|iPod|Best Buy|0
450|iPad|Amazon|1
24.87|Battery pack|Amazon|2
249.99|Chromebook|Amazon|3
215|iPod|Target|4
238.79|Chromebook|Walmart|5

يمكننا إيضاً استخدام `AND`، `OR` و `NOT` لتحديد استعلامنا بشكل ادق. مثلاً، للبحث عن منتجات Amazon والتي لا تحتوي على Battery pack وسعرها اقل من $300، نكتب الإستعلام التالي:

```python
sql_expr = """
SELECT *
FROM prices
WHERE retailer = 'Amazon'
    AND NOT product = 'Battery pack'
    AND price < 300
"""
pd.read_sql(sql_expr, sqlite_engine)
```

**price**|**product**|**retailer**| 
:-----:|:-----:|:-----:|:-----:
249.99|Chromebook|Amazon|0

ولكتابة نفس الأمر في بانداز:

```python
prices[(prices['retailer'] == 'Amazon') 
   & ~(prices['product'] == 'Battery pack')
   & (prices['price'] <= 300)]
```

**price**|**product**|**retailer**| 
:-----:|:-----:|:-----:|:-----:
249.99|Chromebook|Amazon|4

نلاحظ هناك وجود فرق يجب التنبيه عنه، الرقم التسلسلي للمنتجى Chromebook في استعلام SQL كان 0، ولكن في استعلام بايثون 4. هذا لأن استعلامات SQL تقوم دائماً بعرض البيانات في جدول جديد وبأرقام تسلسليه جديده تبدأ من 0، ولكن في بانداز، تقوم بعرض جزء من ال DataFrame مع استخدام نفس ارقام التسلسل. يمكننا استخدام الدالة [pd.DataFrame.reset_index](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.reset_index.html) لإعادة تعين الأرقام التسلسليه في بانداز.

#### دوال الجمع

حتى الآن، تعاملنا مع بيانات موجوده في الجداول، يعني ذلك، كل النتائج التي ظهرت سابقاً هي اجزاء من المدخلات في الجداول. ولكن لتطبيق تحليل للبيانات، نحتاج للقيام ببعض عمليات التجميع على بياناتنا. في SQL، يطلق عليها **دوال التجميل Aggregate Functions**.

لنوجد قيمة متوسط اسعار جميع المنتجات في جدول `prices`:

```python
sql_expr = """
SELECT AVG(price) AS avg_price
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

**avg\_price**|
:-----:|:-----:
395.072222|0

وفي بانداز نكتبها:

```python
prices['price'].mean()
```

```ruby
395.0722222222222
```

قائمة كاملة بجميع دوال التجميع في PostgreSQL [هنا](https://www.postgresql.org/docs/9.2/static/functions.html). على الرقم من اننا نستخدمها كاداة اساسيه للتعامل مع SQL في هذه الماده، تذكر ان هناك انواع مختلفه من SQL مثل MySQL، SQLite وغيرها التي تستخدم اسماء مختلفه للدوال وبعض الأحيان تحتوي على دوال مختلفه.

#### GROUP BY و HAVING

بإستخدام دوال التجميع، يمكننا القيام بإستعلامات مُعقده. لإستخدام دوال تجميع سهله التعامل، يمكننا تجربة التاليه:

- `GROUP BY` تستقبل اسماء عواميد وتقوم بجمعها كما في دالة [pd.DataFrame.groupby](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.groupby.html) في بانداز.
- `HAVING` تعمل بشكل مشابه ل `WHERE`1، ولكن تستخدم فقط على البيانات الناتجه ممن الدوال المجمعه. (ملاحظه: لإستخدام `HAVING`، يجب ان تكون مسبوقه ب `GROUP BY`)

**ملاحظه مهمه:** عند استخدام `GROUP BY`، يجب ان تكون جميع الأعمدة في `SELECT` موجوده في `GROUP BY` او تكون دالة تجميع مطبقه عليها.

يمكننا استخدام الإستعلام التالي لإيجاد اعلى سعر لكل متجر:

```python
sql_expr = """
SELECT retailer, MAX(price) as max_price
FROM prices
GROUP BY retailer
"""
pd.read_sql(sql_expr, sqlite_engine)
```

**max\_price**|**retailer**| 
:-----:|:-----:|:-----:
450|Amazon|0
719|Best Buy|1
799|Target|2
238.79|Walmart|3

لنقل أن لدينا عميل ذو ذوق عالي ويريد فقط تلك المتاجر التي تتبيع منتجات بسعر أعلى من $700. لاحظ ان يجب علينا استخدام `HAVING` لإيجاد النتيجه من عامود تم تجميعه؛ لا يمكننا استخدام `WHERE` لفلترة نتائج عامود مُجَمع. لإيجاد قائمة بالمتاجر التي تبيع المنتجات المفضله لعميلنا نقوم بالتالي:

```python
sql_expr = """
SELECT retailer, MAX(price) as max_price
FROM prices
GROUP BY retailer
HAVING max_price > 700
"""
pd.read_sql(sql_expr, sqlite_engine)
```

**max\_price**|**retailer**| 
:-----:|:-----:|:-----:
719|Best Buy|0
799|Target|1

وللمقارنه مع بايثون:

```python
max_prices = prices.groupby('retailer').max()
max_prices.loc[max_prices['price'] > 700, ['price']]
```

|**price**||
:-----:|:-----:
||**retailer**
719|**Best Buy**
799|**Target**|

#### ORDER BY و LIMIT

تُمكنا الأوامر التاليه من التحكم بكيفية عرض البيانات:

- `ORDER BY` تساعدنا على عرض البيانات بشكل مُرتب بناءًا على القيم داخل العامود. بشكل تلقائي، `ORDER BY` تستخدم الترتيب التصاعدي `ASC` ولكن يمكننا عكسها وعرض البيانات بشكل تنازلي باستخدام `DESC`.
- `LIMIT` تسمح لنا بتحديد كم من البيانات نعرض.

لنقم بعرض ارخص المنتجات في جدول `prices`:

```python
sql_expr = """
SELECT *
FROM prices
ORDER BY price ASC
LIMIT 3
"""
pd.read_sql(sql_expr, sqlite_engine)
```

**price**|**product**|**retailer**| 
:-----:|:-----:|:-----:|:-----:
24.87|Battery pack|Amazon|0
200|iPod|Best Buy|1
215|iPod|Target|2

لاحظ اننا لم نحتاج لإضافة `ASC` لأن `ORDER BY` تجلب لنا البيانات بترتيب تصاعدي بشكل تلقائي. للمقارنه مع بانداز:

```python
prices.sort_values('price').head(3)
```

**price**|**product**|**retailer**| 
:-----:|:-----:|:-----:|:-----:
24.87|Battery pack|Amazon|3
200|iPod|Best Buy|1
215|iPod|Target|5

مره أخرى، نلاحظ ان الأرقام التسلسليه غير مرتبه في بانداز. كما في السابق، بانداز تقوم بعرض DataFrame كما هي، عل عكس SQL التي تنشأ جدول جديد عند كُل استعلام.

#### ترتيب الأوامر في SQL

تطبق الأوامر في SQL بشكل مُرتب. للأسف، ان الترتيب مختلف عن ما يظهر في كتابة الأستعلام. ترتيب الأوامر كالتالي:

- `FROM`: جدول او اكثر من جدول.
- `WHERE`: تطبيق شروط على الأسطر.
- `GROUP BY`: التجميع.
- `HAVING`: تطبيق الشروط على التجميع.
- `SELECT`: اختيار العواميد

**ملاحظه في `WHERE` و `HAVING`**: بما ان `WHERE` تُطبق قبل `GROUP BY`، فأن `WHERE` لا تفيدنا عندما نقوم بالتجميع. لذا، للتعامل مع بيانات مجمعه نستخدم `HAVING`.

### ملخص SQL

في هذا الجزء قمنا بشرح طريقة كتابة استعلامات SQL واهم الأوامر لإجراء تحليل للبيانات بإستخدام انظمة قواعد البيانات العلائقيه.

## الربط في SQL

في بانداز يمكننا استخدام الداله `pd.merge` لجمع جدولين معاً يحتويان على قيم متشابهه في أحد العواميد. مثلاً:

```python
pd.merge(table1, table2, on='common_column')
```

في هذا الجزء، سنتعلم الجمع فيه SQL والذي يفيدنا في جمع اكثر من جدول في قواعد البيانات العلائقيه.

لنفرض مثلاً اننا متجر لمنتجات القطط ولدينا قاعدة بيانات بالقطط التي في متجرنا. لدينا **جدولين** مختلفين: `names` و `colors`. جدول `names` يحتوي على العامودان:
- `cat_id`: رقم مميز لكل قط.
- `name`: اسم القط.
جدول `colors` يحتوي على العامودان:
- `cat_id`: رقم مميز لكل قط.
- `color`: لون كل قط.

لاحظ وجود قيم مفقوده في كل جدول. القيمه 3 في العامود `cat_id` مفقوده من جدول `names`، والقيمه 4 من عامود `cat_id` مفقوده في جدول `colors`

<div>
<table>
<tr><th>Names Table </th><th> Colors Table</th></tr>
<tr style="background-color: transparent;"><td style="border: none; text-align: center;">
<table>
    <tr>
        <td><b>cat_id</b></td>
        <td><b>name</b></td>
    </tr>
    <tr>
        <td>0</td>
        <td>Apricot</td>
    </tr>
    <tr>
        <td>1</td>
        <td>Boots</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Cally</td>
    </tr>
    <tr>
        <td>4</td>
        <td>Eugene</td>
    </tr>
</table>


</td><td style="border: none; text-align: center;">


<table>
    <tr>
        <td><b>cat_id</b></td>
        <td><b>color</b></td>
    </tr>
    <tr>
        <td>0</td>
        <td>orange</td>
    </tr>
    <tr>
        <td>1</td>
        <td>black</td>
    </tr>
    <tr>
        <td>2</td>
        <td>calico</td>
    </tr>
    <tr>
        <td>3</td>
        <td>white</td>
    </tr>
</table>

</td></tr> 
</table>
</div>

لإيجاد لون القط ذو الأسم Apricot، يجب علينا استخدام معلومه من جدولين. يمكننا ربط الجدولين بإستخدام العامود `cat_id`، ويكون لدينا جدول جديد يحتوي على `name` و `color`.

### الربط

الربط بين عدة جداول بإستخدام قيم في عواميدها.

يوجد اربع انواع من الربط: الربط الداخلي Inner Join, الربط الخارجي Outer Join او الكامل Full Join, الربط اليميني Right Join والربط اليساري Left Join. بالرغم بأن جميعها تربط بين الجداول وتقوم بجمعها، إلا ان كل نوع يعامل القيم بطريقة مختلفه.

#### Inner Join

**تعريف:** في الربط الداخلي، الجدول النهائي يحتوي على **القيم المتشابهه** في الجدولين المربوطين معاً.

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter9/img_innerjoin.gif'>
</p>

**مثال:** نريد الربط بين جدولي `names` و `colors` لجمع كل قطه مع لونها. بما ان كلا الجدولين يحتويان على العامود `cat_id` وهو رقم مميز لكل قط، يمكننا استخدام الربط الداخلي بإستخدام العامود `cat_id`.

**SQL:** لكتابة الربط الداخلي في SQL، نقوم بتعديل `FROM` بإضافة `INNER JOIN` عليها:

```python
SELECT ...
FROM <TABLE_1>
    INNER JOIN <TABLE_2>
    ON <...>
```

مثلاً:

```python
SELECT *
FROM names AS N
    INNER JOIN colors AS C
    ON N.cat_id = C.cat_id;
```

| **color**  | **cat\_id** | **name**    | **cat\_id** |   |
|:--------:|:---------:|:---------:|:---------:|:---:|
| orange | 0       | Apricot | 0       | 0 |
| black  | 1       | Boots   | 1       | 1 |
| calico | 2       | Cally   | 2       | 2 |

يمكنك التحقق من ان كل اسم قطه حصل على لونها الصحيح. لاحظ، القطه صاحبة `cat_id` رقم 3 و 4 لم يتم جمعها في الجدول النهائي لأن جدول `colors` لا يحتوي على سطر بقيمة `cat_id` تساوي 4 و جدول `names` لا يحتوي على سطر `cat_id` بقيمة 3. في الدمج الداخي، اذا لم يكون هناك قيم متشابهه في كلا الجدولين، لن يتم ضم القيمه في النتيجة النهائيه.

لنفترض ان لدينا DataFrame بأسم `names` وأخرى بأسم `colors`، يمكننا كتابة الدمج الداخلي في بانداز بالطريقة التاليه:

```python
pd.merge(names, colors, how='inner', on='cat_id')
```

#### Full/Outer Join

**تعريف:** في الربط الكامل/الخارجي، **كل القيم في كلا الجدولين** يتم أضفاتها في الجدول النهائي. اذا كانت القيمه موجوده في جدول دون الآخر، فيتم تعويضها ب `NULL`.

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter9/img_fulljoin.gif'>
</p>

**مثال:** كما في السابق، نريد الربط بين الجدول `names` و `colors` لإعطاء كل قطه لونها. هذه المره، نريد اظهار جميع القيم في الجداول حتى لو لا يجود لها قيم مُطابقه.

**SQL:** لكتابة الربط الكامل/الخارجي في SQL، نقوم بتعديل `FROM` بإضافة `FULL JOIN` عليها:

```python
SELECT ...
FROM <TABLE_1>
    FULL JOIN <TABLE_2>
    ON <...>
```

مثلاً:

```python
SELECT name, color
FROM names N
    FULL JOIN colors C
    ON N.cat_id = C.cat_id;
```

| **color**  | **name**    | **cat\_id** |
|:--------:|:---------:|:---------:|
| orange | Apricot | 0       |
| black  | Boots   | 1       |
| calico | Cally   | 2       |
| white  | NULL    | 3       |
| NULL   | Eugene  | 4       |

لاحظ في النتيجه النهايه ظهور القيم 3 و 4 في عامود `cat_id`. اذا كانت احد القيم تظهر في جدول دون الآخر، فيتم اضافتها للجدول النهائي مع القيمه `NULL` بدلاً من القيم المفقوده.

في بانداز نكتبها كالتالي:

```python
pd.merge(names, colors, how='outer', on='cat_id')
```

#### Left Join

**تعريف:** جميع القيم في الجدول على اليسار يتم ربطها في الجدول النهائي. اذا كانت قيمه في الجدول اليساري لا توجد لها مطابق على الجدول الآخر، يتم تعويض قيمتها المفقوده ب `NULL`.

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter9/img_leftjoin.gif'>
</p>

**مثال:** نربط الجدولان `names` و `colors` لإظهار ألوان القطط. هنا، نريد إظهار جميع اسماء القطط حتى لو لم يكن لها لون في الجدول `colors`.

**SQL:** لكتابة الربط اليساري في SQL، نقوم بتعديل `FROM` بإضافة `LEFT JOIN` عليها:

```python
SELECT ...
FROM <TABLE_1>
    LEFT JOIN <TABLE_2>
    ON <...>
```

مثلاً:

```python
SELECT name, color
FROM names N
    LEFT JOIN colors C
    ON N.cat_id = C.cat_id;
```

| **color**  | **name**    | **cat\_id** |
|:--------:|:---------:|:---------:|
| orange | Apricot | 0       |
| black  | Boots   | 1       |
| calico | Cally   | 2       |
| NULL   | Eugene  | 4       |

لاحظ أن الجدول النهائي يحتوي على جميع اسماء القطط. ثلاثه من القيم `cat_id` في جدول `names` تحتوي على قيم بنفس ال `cat_id` في جدول `colors` وواحده لا تحتوي على قيمه مطابقه (Eugene). القط الذي لا يوجد له لون تم تعويض قيمته ب `NULL`.

في بانداز نكتب الاستعلام كالتالي:

```python
pd.merge(names, colors, how='left', on='cat_id')
```

#### Right Join

**تعريف:** جميع القيم في الجدول على اليمين يتم ربطها في الجدول النهائي. اذا كانت قيمه في الجدول اليميني لا توجد لها مطابق على الجدول الآخر، يتم تعويض قيمتها المفقوده ب `NULL`.

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter9/img_rightjoin.gif'>
</p>

**مثال:** الجدولان `names` و `colors`، نريد ربطها كل قط بلونه. لكن، نريد اظهار جميع ألوان القطط حتى لو لم يكن لها اسماء.

**SQL:** لكتابة الربط اليمين في SQL، نقوم بتعديل `FROM` بإضافة `RIGHT JOIN` عليها:

```python
SELECT ...
FROM <TABLE_1>
    RIGHT JOIN <TABLE_2>
    ON <...>
```

مثلاً:

```python
ELECT name, color
FROM names N
    RIGHT JOIN colors C
    ON N.cat_id = C.cat_id;
```

| **color**  | **name**    | **cat\_id** |
|:--------:|:---------:|:---------:|
| orange | Apricot | 0       |
| black  | Boots   | 1       |
| calico | Cally   | 2       |
| white  | NULL    | 3       |

هذه المره، الجدول النهائي يظهر جميع الألوان. ثلاثه من القيم في العامود  `cat_id` بجدول `colors` لديها مطابق في عامود `cat_id` بجدول `names` وقيمه واحد لم تجد مطابق (white). اللون الذي لم يجد له اسم مطابق سيعوض بالقيمه `NULL`.

في بانداز:

```python
pd.merge(names, colors, how='right', on='cat_id')
```


#### Implicit Inner Join

عادةً توجد اكثر من طريقه لإيجاد نتيجه معينه في SQL تماما كما في بايثون يوجد اكثر من طريقه لحل مشاكل. سنوضح طريقه اخرى لكتابة استعلامات Inner Join تسمى *Implicit Join*.

كتبنا سابقاً الربط الداخلي التالي:

```python
SELECT *
FROM names AS N
    INNER JOIN colors AS C
    ON N.cat_id = C.cat_id;
```

الطريقه الأخرى *Implicit* لكتابة هذا الأمر يكون شكلها مختلف وبدون `INNER JOIN`. لاحظ ان `FORM` يستخدم فيها الفواصل بين جدولين والشرط `WHERE` يحدد شروط الربط:

```python
SELECT *
FROM names AS N, colors AS C
WHERE N.cat_id = C.cat_id;
```

عند استخدام اكثر من جدول في `FORM`، تقوم SQL بإنشاء جدول يحتوي على كل سطر بكلا الجدولين، مثلاً:

```python
sql_expr = """
SELECT *
FROM names N, colors C
"""
pd.read_sql(sql_expr, sqlite_engine)
```

| **color** | **cat_id** | **name** | **cat_id** |  |
|:---------:|:----------:|:--------:|:----------:|:----:|
| orange    | 0          | Apricot  | 0          | 0    |
| black     | 1          | Apricot  | 0          | 1    |
| calico    | 2          | Apricot  | 0          | 2    |
| white     | 3          | Apricot  | 0          | 3    |
| orange    | 0          | Boots    | 1          | 4    |
| black     | 1          | Boots    | 1          | 5    |
| calico    | 2          | Boots    | 1          | 6    |
| white     | 3          | Boots    | 1          | 7    |
| orange    | 0          | Cally    | 2          | 8    |
| black     | 1          | Cally    | 2          | 9    |
| calico    | 2          | Cally    | 2          | 10   |
| white     | 3          | Cally    | 2          | 11   |
| orange    | 0          | Eugene   | 4          | 12   |
| black     | 1          | Eugene   | 4          | 13   |
| calico    | 2          | Eugene   | 4          | 14   |
| white     | 3          | Eugene   | 4          | 15   |

يطلق على هذه العمليه *بالضرب الديكارتي Cartesian product*، كل سطر في الجدول الأول يربط بكل سطر في الجدول الثاني. لاحظ ان الكثير من الأسطر تحتوي على ألوان قطط لا تتطابق مع اسمائها. الشرط الأضافي في `WHERE` يطبق الربط ويفلتر القيم التي لا تتطابق في عامود `cat_id`:

```python
SELECT *
FROM names AS N, colors AS C
WHERE N.cat_id = C.cat_id;
```

| **color**  | **cat\_id** | **name**    | **cat\_id** |   |
|:--------:|:---------:|:---------:|:---------:|:---:|
| orange | 0       | Apricot | 0       | 0 |
| black  | 1       | Boots   | 1       | 1 |
| calico | 2       | Cally   | 2       | 2 |

### ربط أكثر من جدول

لربط أكثر من جدول، نضيف على المتغير `FROM` اوامر الربط `JOIN`. مثلاً، جدول الأعمار للقطط:

| **cat_id** | **age** |
|:----------:|:-------:|
| 0          | 4       |
| 1          | 3       |
| 2          | 9       |
| 4          | 20      |

لإجراء عملية الربط الداخلي على الجداول `neams`، `colors` و `ages` نكتب التالي:

```python
sql_expr = """
SELECT name, color, age
    FROM names n
    INNER JOIN colors c ON n.cat_id = c.cat_id
    INNER JOIN ages a ON n.cat_id = a.cat_id;
"""
pd.read_sql(sql_expr, sqlite_engine)
```

| **age** | **color** | **name** |  |
|:-------:|:---------:|:--------:|:----:|
| 4       | orange    | Apricot  | 0    |
| 3       | black     | Boots    | 1    |
| 9       | calico    | Cally    | 2    |

### ملخص الربط

قمنا بعرض الأربع انواع الأساسيه للربط في SQL: الربط الداخلي، الكامل، اليميني واليساري. نستخدم جميع الأنواع في الربط للقيام بعمليات الربط بين الجداول المنفصله التي تربطها علاقات، كل عملية ربط لديها طرق مختلفه للربط بين القيم.