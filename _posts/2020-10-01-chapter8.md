---
title: التعامل مع النصوص
show_title: true
chapter_number: 8
chapter_text: الفصل الثامن
chapter_lessons: [[0, 'مقدمة'], [1, 'دوال النصوص في بايثون'], [2, 'التعابير النمطية RegEx'], [3, 'التعابير النمطية في بايثون وبانداز']]
chapter_sublessons: [
    [],
    ['دوال النصوص في بايثون', 'تنظيف البيانات النصيه', 'دوال النصوص', 'دوال النصوص في بانداز', 'ملخص دوال النصوص'],
    [['كتابة أوامر التعابير النمطية', 'حرفياً', 'رموز خاصه', 'المجموعات النصيه', 'عكس المجموعات النصيه', 'الحدود الرقمية', 'تحديد المكان', 'تجاهل الرموز الخاصه'], 'مرجع التعابير النمطية', 'ملخص التعابير النمطية RegEx'],
    ['RE.SEARCH', 'RE.FINDALL', 'مجموعات RegEx', 'RE.SUB', 'RE.SPLIT', 'التعابير النمطية و بانداز', 'ملخص التعابير النمطية في بايثون وبانداز']
]
layout: default
---

## مقدمة

الكثير من البيانات التي نواجهها في ملف CSV ليست أرقام بس نصوص موجوده في كُتب، ملفات، تدوينات، او تعليقات في الانترنت. كما في الكثير من انواع البيانات، هناك طرق مختلفه للتعامل مع النصوص وقد نحتاج لكتابة اكثر من كتاب لشرحها بشكل تفصيلي. في هذا الفصل، سنشرح جزء بسيط من هذه التقنيات والتي توفر لنا العديد من العمليات المفيده للعمل مع النصوص: معالجة نصوص بايثون و التعابير النمطية RegEx.

## دوال النصوص في بايثون

توفر لنا بايثون العدد من الدوال للتعامل مع النصوص. رغم بساطتها، تعد هذه الدوال من الأولويات في التعامل مع النصوص والتي جُمعت مع بعضها البعض لتكون دوال اكثر تعقيداً. سنقوم بشرح دوال بايثون للتعامل مع النصوص حسب كثرة الإستخدام في تنظيف البيانات النصيه.

### تنظيف البيانات النصيه

تأتي البيانات عادةً من عدة مصادر وكل مصدر لديه طريقه مختلفه لترميز المعلومات. في المثال التالي، لدينا جدول يحتوي على الولايات الأمريكيه والمقاطعات التي تشملها وجدول آخر يحتوي على عدد سكان المقاطعه.

```python
state = pd.DataFrame({
    'County': [
        'De Witt County',
        'Lac qui Parle County',
        'Lewis and Clark County',
        'St John the Baptist Parish',
    ],
    'State': [
        'IL',
        'MN',
        'MT',
        'LA',
    ]
})
population = pd.DataFrame({
    'County': [
        'DeWitt  ',
        'Lac Qui Parle',
        'Lewis & Clark',
        'St. John the Baptist',
    ],
    'Population': [
        '16,798',
        '8,067',
        '55,716',
        '43,044',
    ]
})
```

**State**|**County**| 
:-----:|:-----:|:-----:
IL|De Witt County|0
MN|Lac qui Parle County|1
MT|Lewis and Clark County|2
LA|St John the Baptist Parish|3

<br>

**Population**|**County**| 
:-----:|:-----:|:-----:
16,798|DeWitt|0
8,067|Lac Qui Parle|1
55,716|Lewis & Clark|2
43,044|St. John the Baptist|3

بالطبع نريد جمع جدولي `state` و `population` معاً بإستخدام العامود `County`. للأسف، لا تتطابق أي من اسماء المقاطعات في الجدولين. هذا المثال يوضح عدد من المشاكل في البيانات النصيه وهي كالتالي:

- الكتابة بحروف كبيره / صغيره: `qui` و `Qui`.
- علامات ترقيم مختلفة: `St.` و `St`.
- عدم كتابة بعض الكلمات: مثلاً كلمتي `County`/`Parish` لم يتم كتابتها في جدول `population`.
- اضافة مسافات: `DeWitt` و `De Witt`.
- استخدام مُختلف للإختصارات: `&` و `and`.

### دوال النصوص

دوال النصوص في بايثون تساعدنا بالبدء في حل هذه المشاكل. هذه الدوال مُعرّفه في جميع نسخ بايثون لذا لا نحتاج لإستخادم اي مكتبه أخرى. على الرغم انه مهم جداً لك شخصياً معرفة [جميع الدوال للتعامل مع النصوص](https://docs.python.org/3/library/stdtypes.html#string-methods)، قمنا بشرح بعض من اكثر الدوال استخداماً في الجدول التالي:

**الداله**|**الوصف**
:-----:|:-----:
str[x:y]| تقوم الداله بفصل النص `str` من `x` (تشمل الحرف) حتى `y` (لا تشمل الحرف). 
()str.lower| تنشئ نسخه من النص `str` بعد تحويل جميع الحروف فيه إلى حروف صغيره. 
str.replace(a, b)| تحويل جميع مرات ظهور النص/الحرف `a` في  `str` إلى النص/الحرف `b`. 
str.split(a)| تقوم الدالة بفصل النص `str` عند ظهور النص/الحرف `a`. 
()str.strip| تحذف الداله المسافات الفارغه في بداية ونهاية النص `str` 

قمنا بإختيار النص `St. John the Baptist` من جدولي `state` و `population` لتطبيق دوال النصوص بحذف الحروف الكبيره، علامات الترقيم، و التخصل من الكلمتين `county` و `parish`:

```python
john1 = state.loc[3, 'County']
john2 = population.loc[3, 'County']

(john1
 .lower()
 .strip()
 .replace(' parish', '')
 .replace(' county', '')
 .replace('&', 'and')
 .replace('.', '')
 .replace(' ', '')
)
```

```ruby
'stjohnthebaptist'
```

تطبيق نفس الدوال على `john2` يأكد لنا ان النصين مُتطابقان:

```python
(john2
 .lower()
 .strip()
 .replace(' parish', '')
 .replace(' county', '')
 .replace('&', 'and')
 .replace('.', '')
 .replace(' ', '')
)
```

```ruby
'stjohnthebaptist'
```

عند الوصول لنتيجة مُقنعه، نقوم بتعريف دالة بأسم `clean_county` والتي ستطبق مهام تنظيف المدخلات (المقاطعات):

```python
def clean_county(county):
    return (county
            .lower()
            .strip()
            .replace(' county', '')
            .replace(' parish', '')
            .replace('&', 'and')
            .replace(' ', '')
            .replace('.', ''))
```

يمكننا التأكد ان الداله `clean_county` تقوم بتوحيد جميع اسماء المقاطعات عبر تطبيقها على الجدولين:

```python
([clean_county(county) for county in state['County']],
 [clean_county(county) for county in population['County']]
)
```

```ruby
(['dewitt', 'lacquiparle', 'lewisandclark', 'stjohnthebaptist'],
 ['dewitt', 'lacquiparle', 'lewisandclark', 'stjohnthebaptist'])
```

بما ان كلا العامودين الآن يحتويان على نفس اسم المقاطعه وبنفس الشكل، يمكننا جمع الجدولين معاً بإستخدام اسم المقاطعه.

### دوال النصوص في بانداز

في الكود البرمجي السابق، استخدمنا التكرار Loop لتغير أسامي المقاطعات. مصفوفات `pandas` تقدم طريقة اسهل لتطبيق دوال النصوص لجميع محتوى المصفوفه. اولاً، لنرى اسماء المقاطعات في جدول `state`:

```python
state['County']
```

```ruby
0                De Witt County
1          Lac qui Parle County
2        Lewis and Clark County
3    St John the Baptist Parish
Name: County, dtype: object
```

الدالة `.str` في مصفوفات بانداز تتعامل مع النص كما في بايثون. استخدام الدوال على `.str` يطبقها على جميع القيم في المصفوفه:

```python
state['County'].str.lower()
```

```ruby
0                de witt county
1          lac qui parle county
2        lewis and clark county
3    st john the baptist parish
Name: County, dtype: object
```

يُمكنا ذلك من تحويل جميع النصوص في المصفوفه دون الحاجه لإستخدام التكرار:

```python
(state['County']
 .str.lower()
 .str.strip()
 .str.replace(' parish', '')
 .str.replace(' county', '')
 .str.replace('&', 'and')
 .str.replace('.', '')
 .str.replace(' ', '')
)
```

```ruby
0              dewitt
1         lacquiparle
2       lewisandclark
3    stjohnthebaptist
Name: County, dtype: object
```

نعيد حفظ نتيجة تغير شكل عامود المقاطعات على نفس العامود:

```python
state['County'] = (state['County']
 .str.lower()
 .str.strip()
 .str.replace(' parish', '')
 .str.replace(' county', '')
 .str.replace('&', 'and')
 .str.replace('.', '')
 .str.replace(' ', '')
)

population['County'] = (population['County']
 .str.lower()
 .str.strip()
 .str.replace(' parish', '')
 .str.replace(' county', '')
 .str.replace('&', 'and')
 .str.replace('.', '')
 .str.replace(' ', '')
)
```

والآن بما ان كلا الجدولين لديهما نفس التعبير النصي للمقاطعات:

```python
state
```

**State**|**County**| 
:-----:|:-----:|:-----:
IL|dewitt|0
MN|lacquiparle|1
MT|lewisandclark|2
LA|stjohnthebaptist|3

```python
population
```

**Population**|**County**| 
:-----:|:-----:|:-----:
16,798|dewitt|0
8,067|lacquiparle|1
55,716|lewisandclark|2
43,044|stjohnthebaptist|3

من السهل جمع الجدولين عندما يتطابق عامود المناطق:

```python
state.merge(population, on='County')
```

**Population**|**State**|**County**| 
:-----:|:-----:|:-----:|:-----:
16,798|IL|dewitt|0
8,067|MN|lacquiparle|1
55,716|MT|lewisandclark|2
43,044|LA|stjohnthebaptist|3

### ملخص دوال النصوص

توفر بايثون دوال سهله وعمليه للتعامل وتعديل النصوص. مصفوفات بانداز توفر نفس الدوال وتسهل تطبيقها على جميع القيم داخل المصفوفه.

يمكنك تصفح شرح كامل عن دوال النصوص في بايثون [هنا](https://docs.python.org/3/library/stdtypes.html#string-methods) ودوال النصوص في بانداز [هنا](https://pandas.pydata.org/pandas-docs/stable/text.html#method-summary)

## التعابير النمطية RegEx

في هذا الجزء سنتحدث عن التعابير النمطية RegEx، اداة مهمه للتحقق من الأنماط في النصوص.

في النصوص الكبيره، الكثير من النصوص الفرعيه تأتي بعدة اشكال. مثلاً، الجمله في الأسفل تحتوي على رقم هاتف:

```ruby
"give me a call, my number is 123-456-7890."
```

رقم الهاتف يحتوي على الأنماط التاليه:
- ثلاث ارقام.
- متبوعه بخط فاصل.
- متبوعه بثلاث ارقام.
- متبوعه بخط فاصل.
- متبوعه بأربع ارقام.

اذا اعطينا نصاً مكتوب، قد نرغب بإيجاد وسحب ارقام الهواتف فقط. ربماً ايضاً نريد جزء معين من رقم الهاتف، مثلاً، سحب رمز المنطقة (الثلاث ارقام الأولى) قد يوصل لنا مكان تواجد صاحب الرقم المذكور في النص.

للتحقق اذا كان النص يحتوي على رقم هاتف، قد نعرف دالة كالتالي:

```python
def is_phone_number(string):
    
    digits = '0123456789'
    
    def is_not_digit(token):
        return token not in digits 
    
    # ثلاث ارقام
    for i in range(3):
        if is_not_digit(string[i]):
            return False
    
    # متبوعه بخط فاصل
    if string[3] != '-':
        return False
    
    # متبوعه بثلاث ارقام
    for i in range(4, 7):
        if is_not_digit(string[i]):
            return False
        
    # متبوعه بخط فاصل   
    if string[7] != '-':
        return False
    
    # متبوعه بأربع ارقام
    for i in range(8, 12):
        if is_not_digit(string[i]):
            return False
    
    return True
```

وللتحقق:

```python
is_phone_number("382-384-3840")
```

```ruby
True
```

```python
is_phone_number("phone number")
```

```ruby
False
```

الكود العلوي يبدو طويل وغير مرغوب فيه. بدلاً من الدوران على كل الحروف في النص، نفضل ان نحدد النمط واوامر لبايثون تسهل علينا إيجاد الأنماط المطابقه لطلباتنا.

**التعابير النمطية Regular expressions** (وبشكل مختصر **RegEx**) تحل هذه المشكلة بجعلنا ننشأ الأنماط للنصوص. بإستخدامها، يمكننا اعادة تعريف الدالة السابقة `is_phone_number` بسطرين في بايثون:

```python
import re

def is_phone_number(string):
    regex = r"[0-9]{3}-[0-9]{3}-[0-9]{4}"
    return re.search(regex, string) is not None

is_phone_number("382-384-3840")
```

```ruby
True
```

في المثال السابق، استخدمنا التعبير النمطي `[0-9]{3}-[0-9]{3}-[0-9]{4}` لمطابقة أرقام الهواتف. ربما يبدو مبهماً في البداية، ولكن أوامر التعابير النمطية سهلة للتعلم؛ في هذا الجزء شرحنا كل الأوامر.

سنقوم بالتعرف على المكتبه التي تأتي مع بايثون بأسم `re` الخاصه بكتابة وتطبيق عمليات النصوص بإستخدام التعابير النمطية.

### كتابة أوامر التعابير النمطية

سنبدأ أولاً بالتعرف على طريقة الكتابه. التعابير النمطية عادةً ما تُحفظ على شكل نصوص خام Raw String. تعمل تماماً كما تعمل النصوص في بايثون ولكن بدون قوانين خاصه للخطوط المائله.

مثلاً لحفظ النص `hello \ world` في بايثون، نحتاج لكتابة:

```python
# الخطوط المائلة في بايثون تحتاج للتوضيح ليتم تجاهلها في نصوص بايثون العاديه
some_string = 'hello \\ world'
print(some_string)
```

```ruby
hello \ world
```

إستخدام النصوص الخامه يحذف شرط اضافة رمز لتجاهل الخطوط المائله:

```python
# لاحظ ال `r` قبل بداية النص
some_raw_string = r'hello \ world'
print(some_raw_string)
```

```ruby
hello \ world
```

بما ان الخطوط المائلة تظهر بشكل كثير في التعابير النمطية، سنستخدم النصوص الخامه لكتابة جميع التعابير النمطية في هذا القسم.

#### حرفياً

ايجاد حرف بشكل معين بالتحديد في التعبر النمطي يوجد لنا ذلك الحرف فقط. مثلاً، التعبير `r"a"` يوجد لنا أي `"a"` في `"Say! I like green eggs and ham!"`. جميع الأرقام والأحرف ورموز الترقيم يمكن البحث عنها بشكل خاص في التعابير النمطية:

```python
def show_regex_match(text, regex):
    """
    تطبع النص مع تغير اللون لتحديد نمط regex
    """
    print(re.sub(f'({regex})', r'\033[1;30;43m\1\033[m', text))
```

```python
regex = r"green"
show_regex_match("Say! I like green eggs and ham!", regex)
```

<div class="regex">
<pre class="highlight">
Say! I like <span>green</span> eggs and ham!
</pre>
</div>

```python
show_regex_match("Say! I like green eggs and ham!", r"a")
```

<div class="regex">
<pre class="highlight">
S<span>a</span>y! I like green eggs <span>a</span>nd h<span>a</span>m!
</pre>
</div>

في المثال السابق، شاهدنا ان التعابير النمطية يمكنها إيجاد الانماط اينما ظهر في النص المدخل. في بايثون، في بايثون هذه الطريقة تختلف بناءًا على الدالة المدخله لمطابقة التعبير النمطي، بعض الدوال فقط تظهر النتيجه اذا ظهر في بداية النص، والبعض يظهرها اذا ظهرت في اي مكان في النص.

لاحظ ايضاً ان الدالة `show_regex_match` تظهر جميع تكرارات النمط في النص المدخل. مره أخرى، يختلف ذلك حسب دالة بايثون المستخدمه، بعضها يظهر جميع التكرارات والبعض فقط يظهر اول تكرار.

التعابير النمطية تتحسس لحالة وشكل الحرف. في المثال التالي، التعبير يطابق فقط الحرف الصغير `s` في `eggs`، وليس الحرف الكبير `S` في `Say`.

```python
show_regex_match("Say! I like green eggs and ham!", r"s")
```

<div class="regex">
<pre class="highlight">
Say! I like green egg<span>s</span> and ham!
</pre>
</div>

#### رموز خاصه

بعض الرموز لديها معاني خاصه في RegEx. هذه الرموز تساعدنا على إيجاد انماط مختلفه من النصوص.

الرمز `.` (نقطة) تعني انه تطابق أي حرف عدى ان يكون ببداية سطر جديد:

```python
show_regex_match("Call me at 382-384-3840.", r".all")
```

<div class="regex">
<pre class="highlight">
<span>Call</span> me at 382-384-3840.
</pre>
</div>

لنطابق النقطة بشكل خاص يجب علينا تجاهلها كرمز بإضافة `\`:

```python
show_regex_match("Call me at 382-384-3840.", r"\.")
```

<div class="regex">
<pre class="highlight">
Call me at 382-384-3840<span>.</span>
</pre>
</div>

بإستخدام النقطه يمكننا مطابقة انواع مختلفة من الأنماط، سنقوم بكتابة تعبير نمطي لمطابقة ارقام الهواتف. مثلاً، يمككنا اخذ الرقم `382-384-3840` وتبديل كل رقم بنقطة `.`، لتبقى لنا فقط الخطوط الفاصله. النتيجه كالتالي `...-...-....`:

```python
show_regex_match("Call me at 382-384-3840.", "...-...-....")
```

<div class="regex">
<pre class="highlight">
Call me at <span>382-384-3840</span>.
</pre>
</div>

بما ان النقطة تطابق جميع النصوص، النص التالي سيظهر لنا نتيجة خاطئة:

```python
show_regex_match("My truck is not-all-blue.", "...-...-....")
```

<div class="regex">
<pre class="highlight">
My truck is <span>not-all-blue</span>.
</pre>
</div>

#### المجموعات النصيه

تسمح لنا المجموعات النصيه بمطابقة نوع معين من النصوص، يوفر لنا ذلك امكانية انشاء قيود للتطابق بدلاً من `.` لمطابقة اي نص. لإنشاء مجموعة، قم بإضافتها داخل اقواس `[ ]`:

```python
show_regex_match("I like your gray shirt.", "gr[ae]y")
```

<div class="regex">
<pre class="highlight">
I like your <span>gray</span> shirt.
</pre>
</div>

```python
show_regex_match("I like your grey shirt.", "gr[ae]y")
```

<div class="regex">
<pre class="highlight">
I like your <span>grey</span> shirt.
</pre>
</div>

```python
# لا يطابق، المجموعات تطابق حرف واحد فقط من ما تحتويها وليس جميعها
show_regex_match("I like your graey shirt.", "gr[ae]y")
```

<div class="regex">
<pre class="highlight">
I like your graey shirt.
</pre>
</div>

```python
# في هذا المثال، كتابة المجموعه مره اخرى ستطابقها
show_regex_match("I like your graey shirt.", "gr[ae][ae]y")
```

<div class="regex">
<pre class="highlight">
I like your <span>graey</span> shirt.
</pre>
</div>

في مجموعات النصوص، الرمز `.` سيتخدم كحرف وليس كرمز:

```python
show_regex_match("I like your grey shirt.", "irt[.]")
```

<div class="regex">
<pre class="highlight">
I like your grey sh<span>irt.</span>
</pre>
</div>

توجد بعض الحالات المختصره الخاصه التي يمكن استخدامها لمطابقة مجموعات النصوص:

**الإختصار**|**المعنى**
:-----:|:-----:
[0-9]|جميع الارقام
[a-z]|الأحرف الصغيره
[A-Z]|الأحرف الكبيره

<br>

```python
show_regex_match("I like your gray shirt.", "y[a-z]y")
```

```ruby
I like your gray shirt.
```

تُمكنا المجموعات النصيه من انشاء انماط خاصه بأرقام الهواتف:

```python
# استبدلنا النقاط `.` في ...-...-.... ب [0-9] لتحديد النمط على الأرقام
phone_regex = r'[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]'
show_regex_match("Call me at 382-384-3840.", phone_regex)
```

<div class="regex">
<pre class="highlight">
Call me at <span>382-384-3840</span>.
</pre>
</div>

```python
# والآن لا نطابق هذا النص
show_regex_match("My truck is not-all-blue.", phone_regex)
```

```ruby
My truck is not-all-blue.
```

#### عكس المجموعات النصيه

عكس المجموعات يطابق اي نص غير الموجود في المجموعه. لإنشاء هذا التعبير، نضيف النص داخل الأقواس `[^ ]`:

```python
show_regex_match("The car parked in the garage.", r"[^c]ar")
```

<div class="regex">
<pre class="highlight">
The car <span>par</span>ked in the <span>gar</span>age.
</pre>
</div>

#### الحدود الرقمية

لإنشاء تعبير نمطي لمطابقة ارقام الهواتف، كتبنا التالي:

```python
[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]
```

هذا النمط يطابق 3 ارقام، متبوعه بخط، ثم ثلاث ارقام وخط ثم اربع ارقام اخرى.

الحدود الرقميه تسمح لنا مطابقة التكرار في النمط. نحدد عدد مرات التكرار بوضع الرقم داخل اقواس معقوفة `{ }`:

```python
phone_regex = r'[0-9]{3}-[0-9]{3}-[0-9]{4}'
show_regex_match("Call me at 382-384-3840.", phone_regex)
```

<div class="regex">
<pre class="highlight">
Call me at <span>382-384-3840</span>.
</pre>
</div>

```python
# لا تطابق لأن اول جزء مكون من رقمين
phone_regex = r'[0-9]{3}-[0-9]{3}-[0-9]{4}'
show_regex_match("Call me at 12-384-3840.", phone_regex)
```

```ruby
Call me at 12-384-3840.
```

الحدود تطابق جميع النصوص او الفئات النصيه التي كُتبت قبلها. الجدول التالي يظهر شرح لها:

**رمز الحدود الرقميه**|**المعنى**
:-----:|:-----:
{m, n}|مطابقة تكرار النص من m إلى n مرات.
{m}|مطابقة تكرار النص m مرات.
{m,}|مطابقة تكرار النص على الأقل m مرات.
{,n}|مطابقة تكرار النص بالأكثر n مرات.

##### اختصارات الحدود الرقمية

الكثير من الحدود الرقمية التي تستخدم كثيراً تم اختصارها:

**الرمز**|**رمز الحدود الرقمية المفصل**|**المعنى**
:-----:|:-----:|:-----:
*|{0,}|مطابقة تكرار النص 0 أو أكثر.
+|{1,}|مطابقة تكرار النص مره واحده أو أكثر.
?|{0,1}|مطابقة تكرار النص 0 أو مره واحده.

نستخدم الرمز `*` بدلاً من `{0,}` في الأمثلة التاليه:

```python
# تكرار a ثلاث مررات
show_regex_match('He screamed "Aaaah!" as the cart took a plunge.', "Aa*h!")
```

<div class="regex">
<pre class="highlight">
He screamed "<span>Aaaah!</span>" as the cart took a plunge.
</pre>
</div>

```python
# مطابقة المزيد من a
show_regex_match(
    'He screamed "Aaaaaaaaaaaaaaaaaaaah!" as the cart took a plunge.',
    "Aa*h!"
)
```

<div class="regex">
<pre class="highlight">
He screamed "<span>Aaaaaaaaaaaaaaaaaaaah!</span>" as the cart took a plunge.
</pre>
</div>

```python
# عدم وجود a بشكل صغير
show_regex_match('He screamed "Ah!" as the cart took a plunge.', "Aa*h!")
```

<div class="regex">
<pre class="highlight">
He screamed "<span>Ah!</span>" as the cart took a plunge.
</pre>
</div>

##### الحدود الكمية جشعه!

توجد لنا دائماً الحدود الكمية أكثر القيم تطابقاً. تظهر بعض المرات نتائج غير متوقعه:

```python
# حاولنا إيجاد 311 و 911 ولكن تم ايجاد and ايضاً
# لأن
# <311> and <911>
# هي اعلى قيمه ممكنه للنمط <.+>
show_regex_match("Remember the numbers <311> and <911>", "<.+>")
```

<div class="regex">
<pre class="highlight">
Remember the numbers <span><311> and <911></span>
</pre>
</div>

في كثير من الحالات، استخدام مجموعات النصوص يسهل علينا تفادي هذه النتائج الخاطئه:

```python
show_regex_match("Remember the numbers <311> and <911>", "<[0-9]+>")
```

<div class="regex">
<pre class="highlight">
Remember the numbers <span><311></span> and <span><911></span>
</pre>
</div>

#### تحديد المكان

في بعض الأحيان نريد ان يتطابق النمط اذا كان في بداية او نهاية النص. الرمز الخاص `^` يجعل التعبير يطابق النمط عندما يظهر في بداية النص فقط؛ والرمز الآخر الخاص `$` يطابق النمط اذا ظهر في نهاية النص. مثلاً التعبير النمطي `well$` فقط يطابق ظهور كلمة `well` في نهاية النص:

```python
show_regex_match('well, well, well', r"well$")
```

<div class="regex">
<pre class="highlight">
well, well, <span>well</span>
</pre>
</div>

بإستخدام كلا الرمزين `^` و `$` يجعل التعبير يطابق النمط كاملاً:

```python
phone_regex = r"^[0-9]{3}-[0-9]{3}-[0-9]{4}$"
show_regex_match('382-384-3840', phone_regex)
```

<div class="regex">
<pre class="highlight">
<span>382-384-3840</span>
</pre>
</div>

```python
# لا يطابق
# لأن الرقم الأخير ينتهي بنقطة
show_regex_match('You can call me at 382-384-3840.', phone_regex)
```

```ruby
You can call me at 382-384-3840.
```

#### تجاهل الرموز الخاصه

كل الرموز الخاصه لها وظائف معينة في التعبير النمطي. ولمطابقة احد هذه الرموز، يمكننا تجاهل وظيفتها في التعبير النمطي بإستخدام `\`:

```python
show_regex_match("Call me at [382-384-3840].", "\[")
```

<div class="regex">
<pre class="highlight">
Call me at <span>[</span>382-384-3840].
</pre>
</div>


```python
show_regex_match("Call me at [382-384-3840].", "\.")
```

<div class="regex">
<pre class="highlight">
Call me at [382-384-3840]<span>.</span>
</pre>
</div>

### مرجع التعابير النمطية

قمنا بالحديث عن اهم النقاط والرموز في التعابير النمطية. ليكون لدينا مرجع كامل، اضفنا الجدول التالي:

#### مرجع الرموز الخاصه

هذا الجدول يحتوي على اهم الرموز الخاصه، والتي تساعدك على تحديد انماط محدده تريد مطابقتها والبحث عنها في النصوص:


**الرمز**|**الوصف**|**مثال التعبير النمطي**|**يطابق**|**لا يطابق**
:-----:|:-----:|:-----:|:-----:|:-----:
.|يطابق اي حرف عدا سطر جديد|...|abc|ab
 | | | |abcd
[ ]|اي حرف داخل الأقواس|<span style='font-size:1px'>a</span>[cb.]ar|car|jar
 | | |.ar| 
[^ ]|اي حرف غير ما داخل الأقواس|<span style='font-size:1px'>a</span>[^b]ar|car|bar
 | | |par|ar
*|صفر او اكثر تكرار لما يسبق الرمز|<span style='font-size:1px'>a</span>[pb]*ark|bbark|dark
 | | |ark| 
+|واحد او اكثر تكرار لما يسبق الرمز|<span style='font-size:1px'>a</span>[pb]+ark|bbpark|dark
 | | |bark|ark
?|صفر او مره واحد تكرار لما يسبق الرمز|s?he|she|the
 | | |he| 
{n}|مطابقة عدد مرات التكرار n|hello{3}|hellooo|hello
\| |مطابقة أي نمط بين خيارين|we\|[ui]s|we|e
 | | |us|s
 | | |is| 
\\ |تجاهل الرموز الخاصه|	[\\hi]\\ |[hi]|hi
^|بداية السطر|<span style='font-size:1px'>a</span>^ark|ark two|dark
$|نهاية السطر|$<span style='font-size:1px'>a</span>ark|noahs ark|noahs arks

#### مرجع الاختصارات

بعض من الفئات المختصره:

**الرمز المختصر**|**التعبير النمطي الكامل للفئة**|**الوصف**
:-----:|:-----:|:-----:
<span style='font-size:1px'>a</span>\w|[a-zA-Z0-9]|اي حرف صغير/كبير او رقم
<span style='font-size:1px'>a</span>\W|<span style='font-size:1px'>a</span>[^a-zA-Z0-9]|غير اي حرف صغير/كبير او رقم
<span style='font-size:1px'>a</span>\d|[0-9]|ارقام
<span style='font-size:1px'>a</span>\D|<span style='font-size:1px'>a</span>[^0-9]|غير الارقام
<span style='font-size:1px'>a</span>\s|<span style='font-size:1px'>a</span>[\t\n\f\r\p{Z}]|المسافات
<span style='font-size:1px'>a</span>\S|<span style='font-size:1px'>a</span>[^\t\n\f\r\p{z}]|غير المسافات

#### ملخص التعابير النمطية RegEx

في جميع لغات البرمجه توجد مكاتب خاصه لمطابقة الانماط بإستخدام التعابير النمطيه، مما يجعلها مهمه مع اختلاف اللغات. في هذا الجزء، تحدثنا عن طريقة كتابة التعابير النمطيه واهم الرموز المستخدمه.

## التعابير النمطية في بايثون وبانداز

في هذا الجزء، سنتعرف على استخدام مكتبة `re` التعامل مع التعابير النمطية في بايثون. بما اننا تحدثنا على جزء بسيط من اكثر الدوال المستخدمه، يمكنك العودة دائماً إلى [الصفحة الرئيسية لشرح مكتبة `re`](https://docs.python.org/3/library/re.html).

### RE.SEARCH

الداله `re.search(pattern, string)` تطابق جميع الأنماط داخل المتغير `pattern` في النص `string`. يكون نتيجة الداله اما النص اذا وجد تطابق او `None` ان لم يجد:

```python
phone_re = r"[0-9]{3}-[0-9]{3}-[0-9]{4}"
text  = "Call me at 382-384-3840."
match = re.search(phone_re, text)
match
```

```ruby
<_sre.SRE_Match object; span=(11, 23), match='382-384-3840'>
```

عل الرغم ان الكائن الذي انشئ نتيجة لعملية البحث يحتوي على الكثير من الخصائص المفيده، نحن عادةً نستخدم `re.search` للإختبار والتأكد في حال ظهور النمط في النص:

```python
if re.search(phone_re, text):
    print("Found a match!")
```

```ruby
Found a match!
```

```python
if re.search(phone_re, 'Hello world'):
    print("No match; this won't print")
```

دالة اخرى كثيره الإستخدام هي `re.match(pattern, string)` وتعمل بنفس طريقة عمل `re.search` ولكن تقوم بالبحث عن تطابق فقط في بداية النص `string` وليس في اي جزء آخر منه.

### RE.FINDALL

نستخدم الدالة `re.findall(pattern, string)` لإيجاد جميع النتائج التي تطابق النمط. هذه الداله تنتج لنا مصفوفه تحتوي على جميع المطابقات للنمط الذي يكتب في المتغير `pattern` في النص الذي يكتب في المتغير `string`:

```python
gmail_re = r'[a-zA-Z0-9]+@gmail\.com'
text = '''
From: email1@gmail.com
To: email2@yahoo.com and email3@gmail.com
'''
re.findall(gmail_re, text)
```

```ruby
['email1@gmail.com', 'email3@gmail.com']
```

### مجموعات RegEx

استخدام مجموعات RegEx يسمح لنا بمطابقة انماط متعدده واستخراجها منفصله عن طريق اضافتها داخل اقواس `( )`. عندما يحتوي التعبير النمطي على مجموعات، الداله `re.findall` تنتج لنا مصفوفه Tuple تحتوي على نتيجة النمط مفصله.

مثلاً، التعبير النمطي التالي يستخرج ارقام الهواتف من النص:

```python
phone_re = r"[0-9]{3}-[0-9]{3}-[0-9]{4}"
text  = "Sam's number is 382-384-3840 and Mary's is 123-456-7890."
re.findall(phone_re, text)
```

```ruby
['382-384-3840', '123-456-7890']
```

لنقوم بفصل كل ثلاث او اربع ارقام لوحدها من رقم الهاتف، يمكننا جمع كل مجموعة ارقام داخل اقواس:

```python
# نفس التعبير السابق مع اضافة اقواس بين كل 3/4 ارقام
phone_re = r"([0-9]{3})-([0-9]{3})-([0-9]{4})"
text  = "Sam's number is 382-384-3840 and Mary's is 123-456-7890."
re.findall(phone_re, text)
```

```ruby
[('382', '384', '3840'), ('123', '456', '7890')]
```

كما توقعنا، `re.findall` تنتج لنا مجموعه تحتوي على جميع ما يطابق نمط ارقام الهواتف.

### RE.SUB

الداله `re.sub(pattern, replacement, string)` تستبدل جميع تكرارات النمط المكتوب في المتغير `pattern` بالنص البديل في المتغير `replacement` في النص الموجود في المتغير `string`. هذه الداله تعمل كما تعمل دالة `str.sub` في بايثون ولكن تستخدم التعبير النمطي.

في الكود البرمجي التالي، قمنا بتغير التواريخ لنحصل على تواريخ مطابقة بواسطة تبديل الفواصل إلى خطوط:

```python
messy_dates = '03/12/2018, 03.13.18, 03/14/2018, 03:15:2018'
regex = r'[/.:]'
re.sub(regex, '-', messy_dates)
```

```ruby
'03-12-2018, 03-13-18, 03-14-2018, 03-15-2018'
```

### RE.SPLIT

الداله `re.split(pattern, string)` تقوم بفصل النص المدخل في المتغير `string` في كل مره يظهر فيها النمط في المتغير `pattern`. تعمل هذه الداله بنفس طريقة عمل دالة `str.split` في بايثون ولكن تستخدم التعبير النمطي لإتمام عملية الفصل.

في الكود البرمجي التالي، استخدمنا `re.split` لفصل اسماء الفصول من ارقام الصفحات في جدول محتوى الكتاب:

```python
toc = '''
PLAYING PILGRIMS============3
A MERRY CHRISTMAS===========13
THE LAURENCE BOY============31
BURDENS=====================55
BEING NEIGHBORLY============76
'''.strip()

# اولاً فصل كل سطر على حده
lines = re.split('\n', toc)
lines
```

```ruby
['PLAYING PILGRIMS============3',
 'A MERRY CHRISTMAS===========13',
 'THE LAURENCE BOY============31',
 'BURDENS=====================55',
 'BEING NEIGHBORLY============76']
```

```python
# ثم الفصل إلى اسم الفصل ورقم الصفحه
split_re = r'=+' # Matches any sequence of = characters
[re.split(split_re, line) for line in lines]
```

```ruby
[['PLAYING PILGRIMS', '3'],
 ['A MERRY CHRISTMAS', '13'],
 ['THE LAURENCE BOY', '31'],
 ['BURDENS', '55'],
 ['BEING NEIGHBORLY', '76']]
```

### التعابير النمطية و بانداز

تذكر ان مصفوفات بانداز تحتوي على دالة `.str` والتي تدعم دوال التعامل مع النصوص في بايثون. بنفس الطريقه، الداله `.str` تدعم ايضاً بعض الدوال من مكتبة `re`. سنشرح بعض الاستخدامات البسيطه للتعابير النمطية في بانداز، وللمزيد من الدوال في [الصفحة الرئيسية لدوال النصوص في بانداز](https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html).

قمنا بحفظ نص بسيط من اول خمس جمل من رواية *Little Women* في DataFrame. بإستخدام دوال النصوص في بانداز يمكننا استخراج نصوص الحوارات المنطوقه في كل جمله:

```python
text = '''
"Christmas won't be Christmas without any presents," grumbled Jo, lying on the rug.
"It's so dreadful to be poor!" sighed Meg, looking down at her old dress.
"I don't think it's fair for some girls to have plenty of pretty things, and other girls nothing at all," added little Amy, with an injured sniff.
"We've got Father and Mother, and each other," said Beth contentedly from her corner.
The four young faces on which the firelight shone brightened at the cheerful words, but darkened again as Jo said sadly, "We haven't got Father, and shall not have him for a long time."
'''.strip()
little = pd.DataFrame({
    'sentences': text.split('\n')
})
```

```python
little
```

||**الجمله**
:-----:|:-----:
0|<span style='font-size:1px'>a</span>"Christmas won't be Christmas without any pres...<span style='font-size:1px'>a</span>
1|<span style='font-size:1px'>a</span>"It's so dreadful to be poor!" sighed Meg, loo...<span style='font-size:1px'>a</span>
2|<span style='font-size:1px'>a</span>"I don't think it's fair for some girls to hav...<span style='font-size:1px'>a</span>
3|<span style='font-size:1px'>a</span>"We've got Father and Mother, and each other,"...<span style='font-size:1px'>a</span>
4|The four young faces on which the firelight sh...<span style='font-size:1px'>a</span>

بما ان الحوارات المنطوقه تُكتب بين علامتي الاقتباس، سنقوم بكتابة تعبير نمطي بحث عن علامتي الاقتباس، ويوجد داخلها اي نص عدا علامتي اقتباس اخرى، ويجب ان ينتهي النص بعلامة اقتباس:

```python
quote_re = r'"[^"]+"'
little['sentences'].str.findall(quote_re)
```

```ruby
0    ["Christmas won't be Christmas without any pre...
1                     ["It's so dreadful to be poor!"]
2    ["I don't think it's fair for some girls to ha...
3     ["We've got Father and Mother, and each other,"]
4    ["We haven't got Father, and shall not have hi...
Name: sentences, dtype: object
```

بما ان الداله `Series.str.findall` توجد لنا جميع التطابقات، بانداز توفر لنا دالتي `Series.str.extract` و `Series.str.extractall` لإستخراج التطابقات إلى مصفوفة او DataFrame. هذه الدوال تشرط علينا ان يحتوي التعبير النمطي على الأقل على مجموعه واحده:

```python
# ايجاد النصوص بين علامتي اقتباس
quote_re = r'"([^"]+)"'
spoken = little['sentences'].str.extract(quote_re)
spoken
```

```ruby
0    Christmas won't be Christmas without any prese...
1                         It's so dreadful to be poor!
2    I don't think it's fair for some girls to have...
3         We've got Father and Mother, and each other,
4    We haven't got Father, and shall not have him ...
Name: sentences, dtype: object
```

يمككنا اضافة ذلك كعامود في `little`:

```python
little['dialog'] = spoken
little
```

||**sentences**|**dialog**|
:-----:|:-----:|:-----:
0|<span style='font-size:1px'>a</span>"Christmas won't be Christmas without any pres...<span style='font-size:1px'>a</span>|Christmas won't be Christmas without any prese...<span style='font-size:1px'>a</span>
1|<span style='font-size:1px'>a</span>"It's so dreadful to be poor!" sighed Meg, loo...<span style='font-size:1px'>a</span>|It's so dreadful to be poor!<span style='font-size:1px'>a</span>
2|<span style='font-size:1px'>a</span>"I don't think it's fair for some girls to hav...<span style='font-size:1px'>a</span>|I don't think it's fair for some girls to have...<span style='font-size:1px'>a</span>
3|<span style='font-size:1px'>a</span>"We've got Father and Mother, and each other,"...<span style='font-size:1px'>a</span>|We've got Father and Mother, and each other,<span style='font-size:1px'>a</span>
4|The four young faces on which the firelight sh...<span style='font-size:1px'>a</span>|We haven't got Father, and shall not have him ...<span style='font-size:1px'>a</span>

يمكننا ان نأكد ان تلاعبنا بالنصوص بإستخدام التعابير النمطية يعمل بالشكل الذي نرغب به في اخر جمله في ال DataFrame عن طريق طباعة النص الأصلي والنتيجه بعد المطابقه:

```python
print(little.loc[4, 'sentences'])
```

```ruby
The four young faces on which the firelight shone brightened at the cheerful words, but darkened again as Jo said sadly, "We haven't got Father, and shall not have him for a long time."
```

```python
print(little.loc[4, 'dialog'])
```

```ruby
We haven't got Father, and shall not have him for a long time.
```

#### ملخص التعابير النمطية في بايثون وبانداز

مكتبة `re` في بايثون توفر لنا الكثير من الدوال المفيده للتلاعب بالنصوص بإستخدام التعابير النمطية. عند العمل على DataFrame، نستخدم الدالة المماثله للتلاعب بالنصوص بإستخدام التعابير النمطية فيه بانداز.

لعرض كامل شرح مكتبة `re`، [اضغط هنا](https://docs.python.org/3/library/re.html).

لعرض كامل شرح دوال النصوص في بانداز، [اضغط هنا](https://pandas.pydata.org/pandas-docs/stable/text.html).
