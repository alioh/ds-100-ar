---
title: تصوير البيانات
show_title: true
chapter_number: 6
chapter_text: الفصل السادس
chapter_lessons: [[0, 'مقدمة'], [1, 'البيانات الكمية'],[2,'البيانات النوعية'], [3, 'تخصيص الرسوم البيانية'], [4, 'مبادئ تصوير البيانات'], [5, 'مدى البيانات'], [6, 'فلسفة تصوير البيانات']]
chapter_sublessons: [
    [],
    ['تصوير البيانات الكمية', 'المدرج التكراري', 'مخطط الصندوق', 'نقطه بسيطه عن استخدام مكتبة Seaborn', 'مخطط التشَتُّت'],
    ['تصوير البيانات النوعية', 'المخطط الشريطي', 'المخطط النقطي'],
    ['تخصيص الرسوم البيانية بإستخدام matplotlib', 'تخصيص الرسم والأبعاد', 'تخصيص النقاط', 'النصوص ودعم LaTeX','تخصيص رسوم seaborn بإستخدام matplotlib'],
    ['مبادئ المقاييس', 'مبادئ الحالات', 'مبادئ الإدراك', 'مبادئ التحويل', 'مبادئ النصوص', 'مبادئ التبسيط'],
    [],
    [],

]
layout: default
---

## مقدمة

> هناك سحر في الرسوم البيانيه. المنحنى في الرسم يظهر بشكل سريع الحاله — قصة حياة وباء، الهلع، او مرحلة الرخاء.
> المنحنى ينبه العقل، يثير الخيال، يقنعه.
>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;— [هنري دي هوبارد](https://en.wikipedia.org/wiki/Henry_D._Hubbard)
>

التصوير والرسوم البيانيه أداه اساسيه في كل خطوه من خطوات التحليل في علم البيانات، من التنظيف حتى التحليل الاستكشافي للبيانات إلى الوصول لنتائج وتوقعات. لأن العقل البشري متطور للغايه للإدراك البصري، اختيار الرسم البياني الصحيح يظهر لنا الإتجاهات والشذوذ في البيانات بشكل افضل من الوصف النصي.

لتستخدم تصوير البيانات بشكل فعال، يجب ان تكون خبيراً في ادوات البرمجه التي تنشئ الرسوم البيانيه ومبادئ تصوير ورسم البيانات. في هذا الفصل سنتعرف على seaborn و matplotlib، الأدوات التي اخترناها للرسم. سنتعلم ايضاً كيف نكتشف الرسوم البيانيه المضلله وكيف نحسن ممن الرسوم البيانيه بإستخدام تحويل، تبسيط، وتقليل ابعاد البيانات.

## البيانات الكمية

### تصوير البيانات الكمية

عادة ما نستخدم انواع مختلفه من الرسوم البيانية لتصوير البيانات الكمية (الرقمية) و النوعية (الاسمية). 

في البيانات الكمية، عادة ما نستخدم المدرج التكراري Histogram، مخطط الصندوق Box Plot، و مخطط التشَتُّت Scatter Plot.

يمكننا استخدام [مكتبة Seaborn للرسوم البيانية](http://seaborn.pydata.org/) لرسم تلك الرسوم في بايثون. سنستخدم بيانات تحتوي على معلومات رُكاب سفينة تايتانيك.

```python
# جلب المكتبه وتحديد اشكال الرسوم
import seaborn as sns
sns.set()

# تعريف البيانات وحذف الحقول الفارغة
ti = sns.load_dataset('titanic').dropna().reset_index(drop=True)

df_interact(ti)
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/titanic_passengers.png'>
</p>

```ruby
(182 rows, 15 columns) total
```


> كما في الفصل السابق، عرف الكاتب داله تقوم بإظهار اجزاء من البيانات مع امكانية التنقل بينها بواسطة الشريطين في الأعلى
>```python
>def df_interact(df):
>    def peek(row=0, col=0):
>        return df.iloc[row:row + 5, col:col + 8]
>    interact(peek, row=(0, len(df), 5), col=(0, len(df.columns) - 6))
>    print('({} rows, {} columns) total'.format(df.shape[0], df.shape[1]))
>
>df_interact(calls)
>```

### المدرج التكراري

نرى ان كل سطر في البيانات هو معلومات لراكب. كل سطر يحتوي على عمر الراكب والقيمة التي دفعها على التذكره. لنرسم عامود العمر بإستخدام المدرج التكراري. يمكننا استخدام دالة `distplot` الموجودة في Seaborn:

```python
# اضافة ; في النهاية يخبر جوبتر أن لا يظهر النتيجة التي تظهر دائماً بهذا الشكل
# <matplotlib.axes._subplots.AxesSubplot> 
sns.distplot(ti['age']);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_quantitative_7_0.png'>
</p>

بشكل تلقائي، دالة `distplot` في Seaborn ستُظهر منحنى يناسب توزيع البيانات لدينا. يمكننا إظهار Rug Plot والتي تقوم بتحديد اماكن توزيع البيانات على المحور x:

```python
sns.distplot(ti['age'], rug=True);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_quantitative_9_0.png'>
</p>

يمكننا ايضاً التحكم بالتوزيع. بالتعديل على عدد البيانات لكل مجموعة:

```python
sns.distplot(ti['age'], kde=False, bins=30);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_quantitative_11_0.png'>
</p>

### مخطط الصندوق

يعتبر مخطط الصندوق طريقة مناسبة لمعرفة أين تجتمع البيانات. عادةً، نستخدم النسبة 25 و 75 كنقطتي بداية ونهاية للصندوق ونرسم خطاً عند النسبة 50 (المتوسط)، نرسم خارجها خطين لباقي البيانات بدون القيم المتطرفة والتي يرمز لها بنقاط خارج الخطين.

> يمكن تبسيط مخطط الصندوق بالرسمه التاليه:  
> <img src='{{ site.baseurl }}/img/chapter6/box_plot.png'>  
> [مصدر الصورة](https://pro.arcgis.com/en/pro-app/help/analysis/geoprocessing/charts/box-plot.htm)


```python
sns.boxplot(x='fare', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_quantitative_13_0.png'>
</p>

عادةً ما يستخدم الإنحراف الربيعي Inter-Quartile Range (IQR) لتحديد اي النقاط يمكن حسابها كنقاط شاذه في مخطط الصندوق. IQR هو الفرق بين بيانات النسبة 75 و 25:

```python
lower, upper = np.percentile(ti['fare'], [25, 75])
iqr = upper - lower
iqr
```

```ruby
60.299999999999997
```

القيم اكبر من $ 1.5 \times \text{IQR}) $ تكون اعلى من نسبة 75% والقيم اقل من $ 1.5 \times \text{IQR}) $ تكون اسفل النسبة 25% ويتم اعتبارها قيم شاذه ويمكننا مشاهدتها في الرسم البياني لمخطط الصندوق السابق:

```python
upper_cutoff = upper + 1.5 * iqr
lower_cutoff = lower - 1.5 * iqr
upper_cutoff, lower_cutoff
```

```ruby
(180.44999999999999, -60.749999999999986)
```

بالرغم ان المدرج التكراري يظهر كل البيانات مره واحده، يسهل علينا فهم مخطط الصندوق عندما نقسمه حسب نوع البيانات. مثلاً، يمككنا رسم مخطط الصندوق لكل نوع من الرُكاب:

```python
sns.boxplot(x='fare', y='who', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_quantitative_19_0.png'>
</p>

يسهل علينا فهم مخطط الصندوق عند تقسيمه على عكس المدرج التكراري، التالي رسم لنفس البيانات وتقسيمها ولكن في مدرج تكراري:

```python
sns.distplot(ti.loc[ti['who'] == 'woman', 'fare'])
sns.distplot(ti.loc[ti['who'] == 'man', 'fare'])
sns.distplot(ti.loc[ti['who'] == 'child', 'fare']);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_quantitative_21_0.png'>
</p>

### نقطه بسيطه عن استخدام مكتبة Seaborn

ربما لاحظت ان الدالة `boxplot` انشأت مخطط صندوق منفصل لكل نوع داخل العامود `who` وكانت اسهل للكتابة على عكس طريقة الرسم في المدرج التكراري. على الرغم مان `sns.distplot` تستقبل البيانات كمصفوفات، الكثير من الدوال في Seaborn يمكنها قبول البيانات التي على شكل DataFrame ونحدد اي العواميد على المحورين x و y. مثلاً:

```python
# ارسم العامود fare في بيانات ti على المحور x
sns.boxplot(x='fare', data=ti);
```

عندما تكون نوع البيانات في العامود نوعية ( العامود `'who'` يحتوي على `'women'`, `'men'` و `'child'`)، مكتبة Seaborn ستقوم اوتوماتيكياً بتقسيم البيانات حسب نوعها قبل رسمها. لذا لا نحتاج لفلترة البيانات حسب نوعها كما فعلنا في الدالة `sns.distplot`:

```python
# fare (رقمي) على المحور x
# who (نوعي) على المحور y
sns.boxplot(x='fare', y='who', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_quantitative_23_0.png'>
</p>

### مخطط التشَتُّت

مخطط التشَتُّت يستخدم للمقارنة بين قيمتين كمية (رقمية). يمكننا المقارنة بين العامودان `age` و `fare` في بيانات تايتانيك:

```python
sns.lmplot(x='age', y='fare', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_quantitative_25_0.png'>
</p>

بشكل تلقائي تقوم Seaborn بإضافة خط الإنحدار للرسم البياني ومجال ثقة حول خط الإنحدار والذي يهر بلون ازرق شفاف. في حالتنا هذه لا يبدو ان خط الإنحدار صحيح لذا سنقوم بإخفاءة: [📝][Confidence_interval]

```python
sns.lmplot(x='age', y='fare', data=ti, fit_reg=False);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_quantitative_27_0.png'>
</p>

يمكننا تلوين النقاط حسب نوعها. لنستخدم العامود `who` مره أخرى:

```python
sns.lmplot(x='age', y='fare', hue='who', data=ti, fit_reg=False);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_quantitative_29_0.png'>
</p>

من الرسم البياني السابق يمكننا ملاحظة ان أكثر الرُكاب دون ال18 سنة تم تحديدهم كأطفال `child`. لا يبدو أن هناك فرق في سعر التذكره `fare` بين الذكور والأناث، على الرغم أن اعلى تذكرتين سعراً تم شرائها من قبل ذكران.

## البيانات النوعية

### تصوير البيانات النوعية

للبيانات النوعية او التصنيفيه، عادة ما نستخدم المخطط الشريطي Bar Chart او النقطي Dot Chart. سنرى كيف بإمكاننا رسم هذه الرسوم البيانية بإستخدام `seaborn` وبيانات الناجين من سفينة تايتانيك:

```python
import seaborn as sns
sns.set()

ti = sns.load_dataset('titanic').reset_index(drop=True)

df_interact(ti)
```

```ruby
(891 rows, 15 columns) total
```

### المخطط الشريطي

في `seaborn`، يوجد نوعين من المخططات الشريطيه. النوع الأول يستخدم  دالة `countplot` ليقوم بعد عدد مرات تكرار كل نوع في العامود:

```python
# يقوم برسم وحساب عدد الناجين والذين لم ينجو ثم رسم شريط بعددهم
sns.countplot(x='alive', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_qualitative_5_0.png'>
</p>

```python
sns.countplot(x='class', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_qualitative_6_0.png'>
</p>

```python
# كما في مخطط الصندوق، يمكننا التقسيم بشكل اوسع بإستخدام الألوان
sns.countplot(x='alive', hue='class', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_qualitative_7_0.png'>
</p>

والطريقة الأخرى، دالة `barplot`، تجمع البيانات بإستخدام عامود نوعي ويتم تحديد طول الشريط بناءًا على متوسط نتيجة عامود كمي لكل نوع من الانواع.

```python
# لكل نوع ناجي/لم ينجو، قم بحساب ورسم متوسط الأعمار
sns.barplot(x='alive', y='age', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_qualitative_9_0.png'>
</p>

يمكننا حساب طول كل شريط عن طريق جمع العواميد `alive` و `age` وحساب المتوسط للعامود `age`:

```python
ti[['alive', 'age']].groupby('alive').mean()
```

|**Age**||
:-----:|:-----:|
||**alive**|
|30.626179|**no**|
|28.343690|**yes**|

بشكل تلقائي، دالة `barplot` تحاول حساب فاصل ثقه بنسبة 95% بإستخدام Bootstrap لكل متوسط. مشار إليها بالخط الأسود في أعلى الشريط. فاصل الثقه يحاول توضيح انه اذا كانت بيانات تايتانيك تحتوي على عينة عشوائية، الفرق في عمر الراكب بين الذين نجو والذين لم ينجو ليس مهم احصائياً على مستوى 5%.

فواصل الثقة تأخذ وقتاً طويلاً للحساب عندما يكون لدينا بيانات ذات حجم اكبر، لذا من الأفضل عدم حسابها:

```python
sns.barplot(x='alive', y='age', data=ti, ci=False);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_qualitative_13_0.png'>
</p>

### المخطط النقطي

المخطط النقطي يتشابة كثيراً مع المخطط الشريطي. بدلاً من رسم اشرطة، المخطط النقطي يرسم نقطة واحدة تعبر عن نهاية الشريط. نستخدم الدالة `pointplot` في `seaborn` لرسم المخطط النقطي. كما في `barplot`، دالة `pointplot` تقوم بالتجميع اوتوماتيكياً وحساب المتوسط لعامود رقمي، وتحديد فاصل ثقة بنفسة 95% بخطوط عامودية يكون النقطة متوسطها:

```python
# لكل نوع ناجي/لم ينجو، قم بحساب ورسم متوسط الأعمار
sns.pointplot(x='alive', y='age', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_qualitative_15_0.png'>
</p>

المخطط النقطي مفيد جداً عند محاولة مقارنة التغيرات على حسب نوع البيانات:

```python
# عرض نسبة الناجين بناءًا على الفئة
sns.pointplot(x='class', y='survived', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_qualitative_17_0.png'>
</p>

```python
# عرض نسبة الناجين بناءًا على الفئة
# التقسيم ما اذا كان الناجي ذكر بالغ
sns.pointplot(x='class', y='survived', hue='adult_male', data=ti);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_qualitative_18_0.png'>
</p>

## تخصيص الرسوم البيانية

### تخصيص الرسوم البيانية بإستخدام matplotlib

على الرغم ان `seaborn` تُمكنا من رسم العديد من أنواع الرسوم البيانية بشكل سريع، لكنها لا يمكننا التحكم بشكل كامل بالرسم. مثلاً، لا يمكننا في `seaborn` تعديل عنوان الرسم البياني، وعناوين محاور الطول والعرض، او اضافة ملاحظات على الرسم. لذا، يجب علينا استخدام مكتبة `matplotlib` والتي تعتمد عليها `seaborn`

> مكتبة `seaborn` هي بالأساس `matplotlib` ولكن إضيفت لها تحسينات وتعديلات لتتمكن من التعامل مع مكتبة `pandas`.

توفر لنا `matplotlib` الأساسيات لإنشاء الرسوم البيانية في بايثون. على الرغم من انها تمكنا من الحصول على تحكم كامل، إلا انها ايضاً متعبة في العمل، اعادة رسم ما رسمناه سابقاً في `seaborn` بإستخدام `matplotlib` سنحتاج لكتابة العديد من الأسطر البرمجية. بالأصح، يمكننا القول ان `seaborn` هي اختصار مفيد لإنشاء رسوم بيانية في `matplotlib`. نفضل العمل بالرسوم المبدئية المقدمة من `seaborn`، ولكن لتعديل وتخصيص الرسومات لغرض النشر سنحتاج لمعرفة اساسيات العمل في `matplotlib`.

قبل ان نرى المثال الأول، يجب علينا تفعيل دعم مكتبة `matplotlib` في Jupyter Notebook.

```python
# هذا السطر يجعل الرسوم البيانية تظهر كصور في جوبتر بدلاً من ان تظهر في صفحة منفصلة
%matplotlib inline

# الاختصار plt هو اختصار كثير الأستخدام لمكتبة matplotlib
import matplotlib.pyplot as plt
```

### تخصيص الرسم والأبعاد

للرسم في `matplotlib`، نحتاج اولاً لإنشاء شكل بياني او *Figure*، ثم اضافة المحاور *Axes* للشكل. في `matplotlib`، المحور *Axes* هو رسم بياني واحد، والشكل البياني *Figure* يمكن أن يحتوي على عدة محاور على شكل جداول. المحور يحتوي على نقاط *Marks*، وهي الخطوط أو النقاط المرسومه في الرسم البياني:

```python
# انشاء الشكل البياني
f = plt.figure()

# اضافة محور إلى الشكل البياني. المتغير الثاني والثالث تقوم بإنشاء
# جدول بسطر وعامود واحد. المتغير الاول يتحكم بمكان المحور، هنا في الخليه الأولى
ax = f.add_subplot(1, 1, 1)

# انشاء رسم بياني خطي على المحور
ax.plot([0, 1, 2, 3], [1, 3, 4, 3])

# أظهار الرسم البياني، في جوبتر يتم نداء هذه الدالة بشكل اوتوماتيكي
# لذا لن نستخدمها في الأكواد البرمجية القادمة
plt.show()
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_matplotlib_6_0.png'>
</p>

للتخصيص في هذه الرسمه، يمكننا استخدام دوال أخرى على كائن المحور:

> كائن هنا تعني Object

```python
f = plt.figure()
ax = f.add_subplot(1, 1, 1)

x = np.arange(0, 10, 0.1)

# اضافة المتغير label تمكننا من انشاء عنوان للخط
ax.plot(x, np.sin(x), label='sin(x)')
ax.plot(x, np.cos(x), label='cos(x)')
ax.legend()

ax.set_title('Sinusoids')
ax.set_xlabel('x')
ax.set_ylabel('y');
```

كأختصار، `matplotlib` لديها دوال رسم بياني في `plt` يمكنها انشاء شكل بياني ومحور اوتوماتيكياً:

```python
# اختصار لرسم شكل بياني ومحور
plt.plot(x, np.sin(x))

# عند استخدام plt اكثر من مره في نفس الخليه، سيتم إعادة استخدام نفس الشكل والمحور
plt.scatter(x, np.cos(x));
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_matplotlib_10_0.png'>
</p>

يحتوي `plt` على دوال مشابهه للتي في المحور، لذا يمكننا اعادة انشاء احد الرسوم في الأعلى بإستخدام `plt` مباشره:

```python
x = np.arange(0, 10, 0.1)

plt.plot(x, np.sin(x), label='sin(x)')
plt.plot(x, np.cos(x), label='cos(x)')
plt.legend()

# اختصار ل ax.set_title
plt.title('Sinusoids')
plt.xlabel('x')
plt.ylabel('y')

# تحديد مقاسات محوري x و y
plt.xlim(-1, 11)
plt.ylim(-1.2, 1.2);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_matplotlib_12_0.png'>
</p>

### تخصيص النقاط

لتغير خصائص النقاط في الرسمه ( مثلاً، الخطوط في الرسمه السابقه)، يمكننا تمرير المزيد من المتغيرات إلى `plt.plot`: [📝][Pyplot]

```python
plt.plot(x, np.sin(x), linestyle='--', color='purple');
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_matplotlib_14_0.png'>
</p>

تصفح الشرح الخاص بمكتبة `matplotlib` هو اسهل طريقة لمعرفة أي المتغيرات متوفرة لكل دالة. الطريقة الأخرى هي حفظ الكائن الناتج عن دالة الرسم: [📝][Matplotlib]

```python
line, = plot([1,2,3])
```

كائن الخط في الرسم البياني يحتوي على الكثير من الخصائص التي يمكن ان تتحكم فيها، هذه قائمة كاملة بالخصائص:

```python
line.set
```

```ruby
line.set                     line.set_drawstyle           line.set_mec
line.set_aa                  line.set_figure              line.set_mew
line.set_agg_filter          line.set_fillstyle           line.set_mfc
line.set_alpha               line.set_gid                 line.set_mfcalt
line.set_animated            line.set_label               line.set_ms
line.set_antialiased         line.set_linestyle           line.set_picker
line.set_axes                line.set_linewidth           line.set_pickradius
line.set_c                   line.set_lod                 line.set_rasterized
line.set_clip_box            line.set_ls                  line.set_snap
line.set_clip_on             line.set_lw                  line.set_solid_capstyle
line.set_clip_path           line.set_marker              line.set_solid_joinstyle
line.set_color               line.set_markeredgecolor     line.set_transform
line.set_contains            line.set_markeredgewidth     line.set_url
line.set_dash_capstyle       line.set_markerfacecolor     line.set_visible
line.set_dashes              line.set_markerfacecoloralt  line.set_xdata
line.set_dash_joinstyle      line.set_markersize          line.set_ydata
line.set_data                line.set_markevery           line.set_zorder
```

ولكن استخدام `setp` (اختصار لتحديد خاصيه) قد يكون افضل، خاصه عند العمل بشكل تفاعلي كونه يحتوي على وصف، لكي تتعلم الطرق الصحيحه لنداء الدوال اثناء عملك عليها:

```python
line, = plot([1,2,3])
```

```python
setp(line, 'linestyle')
```

```ruby
  linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}
```

```python
setp(line)
```

```ruby
agg_filter: unknown
alpha: float (0.0 transparent through 1.0 opaque)         
animated: [True | False]         
antialiased or aa: [True | False]
...
...
...
```

في النتيجة الأولى يظهر لنا القيم الصحيحه التي يقبلها متغير `linestyle`، وفي النتيجة الثانية يظهر لنا جميع المتغيرات التي يمكن تخصيصها في كائن الخط. يمكنك ذلك بسهولة اكتشفت وتخصيص رسومك البيانية لتحصل على ما تريده. 

### النصوص ودعم LaTeX

في `matplotlib` يمكن اضافة النص لمحور معين أو للشكل البياني ككل.

هذه الأوامر لإضافة نصوص للمحاور:

- set_title(): اضافة عنوان
- set_xlabel(): اضافة عنوان للمحور السيني x-axis
- set_ylabel(): اضافة عنوان للمحور الصادي y-axis
- text(): اضافة نص في مكان معين
- annotate(): اضافة ملاحظة مع امكانية اضافة سهم

والأوامر التالية للشكل البياني:

- figtext(): اضافة نص في مكان معين
- suptitle(): اضافة عنوان

وأي نص من الممكن أن يحتوي على نصوص بشكل LaTeX والمخصصه للعمليات الرياضية، طالما تم اضافتها بداخل علامتي $.

هذا المثال على جميع ما سبق:

```python
fig = plt.figure()
fig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold')

ax = fig.add_subplot(1, 1, 1)
fig.subplots_adjust(top=0.85)
ax.set_title('axes title')

ax.set_xlabel('xlabel')
ax.set_ylabel('ylabel')

ax.text(3, 8, 'boxed italics text in data coords', style='italic',
        bbox={'facecolor':'red', 'alpha':0.5, 'pad':10})

ax.text(2, 6, 'an equation: $E=mc^2$', fontsize=15)

ax.text(3, 2, 'unicode: Institut für Festkörperphysik')

ax.text(0.95, 0.01, 'colored text in axes coords',
        verticalalignment='bottom', horizontalalignment='right',
        transform=ax.transAxes,
        color='green', fontsize=15)


ax.plot([2], [1], 'o')
ax.annotate('annotate', xy=(2, 1), xytext=(3, 4),
            arrowprops=dict(facecolor='black', shrink=0.05))

ax.axis([0, 10, 0, 10]);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_matplotlib_17_0.png'>
</p>

### تخصيص رسوم seaborn بإستخدام matplotlib

والآن بعد ان رأينا كيف نستخدم `matplotlib` لتخصيص الرسم البياني، يمكننا استخدام نفس الدوال للتخصيص في `seaborn` لأن `seaborn` تقوم بإنشاء الرسوم البيانية بإستخدام `matplotlib`:

```python
# تحميل مكتبة seaborn
import seaborn as sns
sns.set()
sns.set_context('talk')

# تحميل البيانات
ti = sns.load_dataset('titanic').dropna().reset_index(drop=True)
ti.head()
```

**alone**|**alive**|**embark\_town**|**deck**|**...**|**age**|**sex**|**pclass**|**survived**| 
:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:
FALSE|yes|Cherbourg|C|...|38|female|1|1|0
FALSE|yes|Southampton|C|...|35|female|1|1|1
TRUE|no|Southampton|E|...|54|male|1|0|2
FALSE|yes|Southampton|G|...|4|female|3|1|3
TRUE|yes|Southampton|C|...|58|female|1|1|4

```center-result
5 rows × 15 columns
```

لنبدأ بهذه الرسمه:

```python
sns.lmplot(x='age', y='fare', hue='who', data=ti, fit_reg=False);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_matplotlib_21_0.png'>
</p>

يمكننا رؤية ان الرسم يحتاج لعنوان وصف افضل لعناوين المحورين x و y. ايضاً، الشخصين اللذين لديهما اعلى التذاكر سعراً نجا، لذا نحتاج لإضافة توضيح ذلك في رسمنا البياني:

```python
sns.lmplot(x='age', y='fare', hue='who', data=ti, fit_reg=False)

plt.title('Fare Paid vs. Age of Passenger, Colored by Passenger Type')
plt.xlabel('Age of Passenger')
plt.ylabel('Fare in USD')

plt.annotate('Both survived', xy=(35, 500), xytext=(35, 420),
             arrowprops=dict(facecolor='black', shrink=0.05));
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_matplotlib_23_0.png'>
</p>

بشكل عملي، سنستخدم `seaborn` لتصفح البيانات بشكل سريع ثم ننتقل إلى `matplotlib` لنحسن من الرسوم بعد اختيارنا للرسم البياني المثالي.

## مبادئ تصوير البيانات

والآن بما ان لدينا الأدوات لرسم وتخصيص الرسوم البيانية، ننتقر للمبادئ الأساسية لتصوير البيانيات. تماماً كما في باقي اقسام علم البيانات، من الصعب تحديد مقاييس معينة لكفاءة رسمه بيانية معينه. لكن، هناك مبادئ اساسيه وجودها يجعل الرسوم البيانية فعالة بشكل كبير ويظهر اتجاهات البيانات. سنناقش ست مبادئ: المقياس، الحاله، الإدراك، التحويل، النصوص، والتبسيط.

### مبادئ المقاييس

يقصد بمبادئ المقاييس هو اختيار المقاسات المناسبة للمحاور x و y في الرسم البياني.

في جلسة استماع في الكونجرس الأمريكي عام 2015، الوكيل شافيتز ناقش تحقيق عن برنامج Planned Parenthood. قام الوكيل بإستخدام الرسم البياني التالي والذي ظهر  في تقرير من قبل مؤسسة Americans United for Life. يقارن الرسم بين اجراءات الإجهاض و فحوص السرطان، كلا الإجرائين يتم تقديمها في Planned Parenthood. (التقرير متوفر بشكل كامل [هنا](https://oversight.house.gov/interactivepage/plannedparenthood)).

ما المريب بهذا الرسم البياني؟ كم نقطة تم رسمها؟

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_planned_parenthood.png'>
</p>

هذا الرسم يخالف مبادئ المقاييس، لا يحسن الإختيار لمحوري x و y.

عندما نختار المحورين x و y في رسمنا البياني، يجب ان نبقي مقاساتنا ثابته على طول المحور. ولكن، الرسمه العلويه تحتوي على مقاسين مختلفين لخطي اجراءات الإجهاض وفحوص السرطان، بداية خط اجراءات الإجهاض ونهاية خط فحوص السرطان يبدوان قريبين من بعضهما على المحور y ولكن الأرقام تظهر العكس. ايضاً، تم رسم النقاط لسنتي 2006 و 2013 ولكن المحور x يحتوي على علامات اضافية لسنوات بينهما ولم يتم استخدامها.

للتحسين من هذا الرسم البياني، يجب علينا إعادة رسم النقاط على مقاس ثابت في المحور y:

> لتحميل بيانات Planned Parenthood [اضغط هنا]({{ site.baseurl }}/files/chapter6/plannedparenthood.csv).

```python
pp = pd.read_csv("data/plannedparenthood.csv")
plt.plot(pp['year'], pp['screening'], linestyle="solid", marker="o", label='Cancer')
plt.plot(pp['year'], pp['abortion'], linestyle="solid", marker="o", label='Abortion')
plt.title('Planned Parenthood Procedures')
plt.xlabel("Year")
plt.ylabel("Service")
plt.xticks([2006, 2013])
plt.legend();
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_principles_4_0.png'>
</p>

يمكن ان نلاحظ ان الفرق في اجراءات الإجهاض قليل مقارنه بالنزول المفاجئ في فحوص السرطان. بدلاً من مقارنة عدد الإجراءات بينهما، ربما من الأفضل مقارنة فرق بالنسبه بين السنتين 2006 و 2013:

```python
percent_change = pd.DataFrame({
    'percent_change': [
        pp['screening'].iloc[1] / pp['screening'].iloc[0] - 1,
        pp['abortion'].iloc[1] / pp['abortion'].iloc[0] - 1,
    ],
    'procedure': ['cancer', 'abortion'],
    'type': ['percent_change', 'percent_change'],
})
ax = sns.barplot(x='procedure', y='percent_change', data=percent_change)
plt.title('Percent Change in Number of Procedures')
plt.xlabel('')
plt.ylabel('Percent Change')
plt.ylim(-0.6, 0.6)
plt.axhline(y=0, c='black');
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_principles_6_0.png'>
</p>

عند اختيار مقاسات المحاور نحاول التركيز على الجزء الذي يحتوي على عدد بيانات اكبر، خاصه عندما نعمل على بيانات المعروفة بأسم الذيل الطويل Long-tailed Data. لاحظ في الرسم البياني التالي الرسمه قبل (يسار) وبعد (يمين) التقريب في على الرسم الأخرى: [📝][LongTailedData]

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_zoom.png'>
</p>

الرسمه على اليمين تفيد اكثر في فهم البيانات. اذا احتاج الأمر، يمكننا رسم اكثر من رسمه بيانيه لأجزاء مختلفة من البيانات. لاحقاً في هذا الفصل، سنتحدث عن تحويل البيانات والذي سيساعدنا في رسم البيانات ذات الذيل الطويل. 

### مبادئ الحالات

تقدم لنا مبادئ الحالات الطرق والوسائل لإظهار التوزيع والعلاقه بين المجموعات الفرعيه في بياناتنا.

يشرف مكتب إحصائيات العمال في الولايات المتحده على اجراء استبيانات علمية لصحة اقتصاد الولايات المتحده. يحتوي موقع المكتب على اداة لإنشاء التقارير بإستخدام هذه البيانات التي استخدمناها لرسم متوسط الأجر الأسبوعي حسب الجنس.

اي المقارنات اسهل في هذا الرسم؟ هل هذه المقارنات هي الأهم؟

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_earnings.png'>
</p>

يبين لنا هذا الرسم لمحه بسيطه على ان الراتب الأجر الأسبوعي يزيد حسب الدرجه العلميه. ولكن، من الصعب تحديد الزياده بالضبط بين كل درجه علميه وأخرى ويصعب أكثر التفريق بين اجور الذكور والإناث في نفس الدرجة العلميه. يمكننا التحقق من اتجاهات المشكلتين السابقتين بإستخدام المخطط النقطي بدلاً من الشريطي:

> لتحميل بيانات الأجور [اضغط هنا]({{ site.baseurl }}/files/chapter6/plannedparenthood.csv).

```python
cps = pd.read_csv("data/edInc2.csv")
ax = sns.pointplot(x="educ", y="income", hue="gender", data=cps)

ticks = ["<HS", "HS", "<BA", "BA", ">BA"]
ax.set_xticklabels(ticks)
ax.set_xlabel("Education")
ax.set_ylabel("Income")
ax.set_title("2014 Median Weekly Earnings\nFull-Time Workers over 25 years old");
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_principles_10_0.png'>
</p>


الخط الذي يربط بين النقاط يوضح تأثير الحصول على درجة البكالوريوس على الأجر الاسبوعي. وضع نقطتي الذكور والاناث فوق بعضهما يسهل علينا ملاحظة زيادة الفارق بينهما كلما زادت الدرجة العلميه.

للمساعده في المقارنه بين المجموعتين الفرعيتين في بياناتنا، حاذي النقاط على المحور x او y واختر ألوان او اشكال مختلفة لكل ممنهما. الخطوط عادةً ما توضح اتجاه البيانات بشكل واضح اكثر من المخططات الشريطيه وهي اختيار افضل لنوعي البيانات النوعية والكمية.

### مبادئ الإدراك

لدى ادراك البشر بعض الخصائص التي يجب ان ننتبه لها عند تصميم رسومنا البيانيه. أول الخصائص في الإدراك البشري اننا ننتبه لبعض الألوان اكثر من أخرى، خاصه في درجات اللون الأخضر. ايضاً، نلاحظ ان الألوان الفاتحه اكبر حجماً من الألوان الغامقه. مثلاً، في الرسم البياني للاجور الاسبوعيه، المخططات الشريطيه الفاتحه تجذف انتباهنا اكثر من الغامقه:

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_earnings.png'>
</p>

عملياً، يجب ان تتأكد ان ألوان رسومك البيانيه ذات ادراك موحد *Perceptually Uniform*. يعني ذلك، شدة الألوان لا تتغير بين كل شريط وآخر في الرسم. في البيانات الكميه، لدينا خياران: اذا كانت البيانات من تتصاعد من الأقل للأعلى فيجب عليك ان تشدد على القيم العليا، لذا تستخدم قالب ألوان متسلسله *Sequential Color Scheme* والتي تعين لوناً فاتحاً للقيم العاليه. اذا كانت كلا القيم العليا والدنيا تحتاج للتنويه عليها، استخدم قالب ألوان معكوس *Diverging Color Scheme* فيه يتم تعيين اللون الفاتح للقيم القريبه من المنتصف. [📝][PerceptuallyUniform], [📝][ColorSchemes]

تحتوي `seaborn` على الكثير من قوالب الألوان. يمكنك تصفحها في شرح المكتبه لمعرفة كيفية التغير بين كل قالب وآخر:
[http://seaborn.pydata.org/tutorial/color_palettes.html](http://seaborn.pydata.org/tutorial/color_palettes.html)

ثاني خصائص الإدراك البشري هي اننا دقيقين اكثر عندما نقارين بين الأطوال واقل دقه عندما نقارن بين المساحات. الرسم البياني التالي للنواتج المحاليه الإجماليه لبلدان أفريقيا:

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_gdp.png'>
</p>

بناءًا على الأرقام، جنوب افريقيا لديها ضعف الناتج المحلي في بالجزائر ولكن ليس من السهل ملاحظة ذالك في الرسم البياني. بدلاً من ذلك، يمكننا استخدام المخطط النقطي للرسم:

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_gdp_v2.png'>
</p>

هذا اوضح بكثير لأنه سمح لنا المقارنه الطول بدلاً من المساحه. الدائرة الجزئية Pie Chart و الرسوم ثلاثية الأبعاد Three-dimensional Charts يصعب ترجمتها بسبب نفس المشكله؛ عملياً نحاول الأبتعاد عن هذه الرسومات.

خاصية الإدراك البشري الثالثه والأخيره هي ان العين تواجه صعوبات عند التنقل بين خطوط الأساس. في الرسم البياني التالي من النوع المساحي المُجَمع (المتكدس) Stacked Area Chart والذي يوضح انبعاثات ثاني اكسيد الكربون بمرور الوقت ومفصله حسب الدوله:

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_emissions.png'>
</p>

من الصعب معرفة ما اذا زادت او نقصت الإنبعاثات في المملكة المتحدة بسبب مشكلة هزهزة خط الأساس *Jiggling Baseline*: خط الأساس (الخط السفلي) للمساحه يهتز اعلى واسفل. ايضاً من الصعب المقارنه بين انبعاثات المملكة المتحدة والصين عندما يكون الطول متشابه (في عام 2000 مثلاً).

نفس المشكلة تظهر في المخطط الشريطي المُجَمع (المتكدس). في الرسم البياني التالي يصعب المقارنه عدد الذين اعمارهم بين 15-64 في المكسيك وألمانيا.

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_bar_stacked.jpeg'>
</p>

يمكننا تحسين رسوم البيانات من النوع المساحي والشريطي المُجمعه (متكدسه) عن طريق تحويلها إلى رسوم خطيه. الرسم البياني التالي لبيانات انبعاثات ثاني اكسيد الكربون بمرور الوقت كخطوط بدلاً من مساحات:

> لتحميل بيانات انبعاثات ثاني اكسيد الكربون بين الدول [اضغط هنا]({{ site.baseurl }}/files/chapter6/CAITcountryCO2.csv).


```python
co2 = pd.read_csv("data/CAITcountryCO2.csv", skiprows = 2,
                  names = ["Country", "Year", "CO2"])
last_year = co2.Year.iloc[-1]
q = f"Country != 'World' and Country != 'European Union (15)' and Year == {last_year}"
top14_lasty = co2.query(q).sort_values('CO2', ascending=False).iloc[:14]
top14 = co2[co2.Country.isin(top14_lasty.Country) & (co2.Year >= 1950)]

from cycler import cycler

linestyles = (['-', '--', ':', '-.']*3)[:7]
colors = sns.color_palette('colorblind')[:4]
lines_c = cycler('linestyle', linestyles)
color_c = cycler('color', colors)

fig, ax = plt.subplots(figsize=(9, 9))
ax.set_prop_cycle(lines_c * color_c)

x, y ='Year', 'CO2'
for name, df in top14.groupby('Country'):
    ax.semilogy(df[x], df[y], label=name)

ax.set_xlabel(x)
ax.set_ylabel(y + "Emissions [Million Tons]")
ax.legend(ncol=2, frameon=True);
```

<p align="center"> 
<img src='{{ site.baseurl }}/img/chapter6/viz_principles_17_0.jpeg'>
</p>

رسم البيانات على شكل خطوط لا يحدث بها اهتزازات في خط الاساس لكل خط لذا من السهل مقارنة الإنبعاثات بين الدول. ايضاً يمكننا ان نرى بوضوح أي الدول زادت فيها الإنبعاثات.

### مبادئ التحويل

تقدم لنا مبادئ التحويل طُرق مفيدة لتغير البيانات في الرسوم البيانيه لإظهار اتجاهاتها بصورة واضحه. عادة ما نستخدم التحويل لإظهار الأنماط في البيانات المنحرفة Skewed Data او العلاقات غير الخطيه بين المتغيرات. [📝][SkewedData], [📝][Nonlinear]

الرسم البياني التالي يوضح توزيع اسعار التذاكر بين كل راكب في سفينة تايتانيك. كما ترى،الرسم منحرف بإتجاه اليمين:

```python
ti = sns.load_dataset('titanic')
sns.distplot(ti['fare'])
plt.title('Fares for Titanic Passengers')
plt.xlabel('Fare in USD')
plt.ylabel('Density');
```

<p align='center'>
<img src='{{ site.baseurl }}/img/chapter6/viz_principles_2_3_0.png'>
</p>

على الرغم ان الرسم البياني يوضح جميع اسعار التذاكر، من الصعب ملاحظة الأنماط فيها لأن البيانات مُتجمعه في الجهه اليسرى. لتحسين ذلك، يمكننا حساب اللوغاريتم الطبيعي Natural logarithm لأسعار التذاكر قبل رسمها:

```python
sns.distplot(np.log(ti.loc[ti['fare'] > 0, 'fare']), bins=25)
plt.title('log(Fares) for Titanic Passengers')
plt.xlabel('log(Fare) in USD')
plt.ylabel('Density');
```

<p align='center'>
<img src='{{ site.baseurl }}/img/chapter6/viz_principles_2_5_0.png'>
</p>

يمكننا ملاحظة في رسم البيانات بعد حساب اللوغاريتميه ان توزيع البيانات حقق منوال قرابة $$e^2 = \$7.40$$ والمنوال الأصغر تقريباً $$e^{3.4} = \$30.00$$. لماذا يفيدنا رسم اللوغاريتميه الطبيعية للبيانات عندما تكون مُنحرفة؟ اللوغاريتميه للأرقام العاليه عادة ما تكون قريبة من اللوغاريتميه للأرقام الصغيره: [📝][LogNormal]

**log(value)**|**value**
:-----:|:-----:
0|1
2.3|10
3.91|50
4.6|100
6.21|500
6.9|1000

يعني ذلك ان اخذ اللوغارتميه للبيانات ذات الأرقام الكبيره على الجانب الأيمن ستجلبها اقرب إلى الأرقام الصغيره. يسهل ذلك في توضيح أين تقع اغلب البيانات.

### مبادئ النصوص

### مبادئ التبسيط


[Confidence_interval]: https://ar.wikipedia.org/wiki/%D9%85%D8%AC%D8%A7%D9%84_%D8%AB%D9%82%D8%A9
[Pyplot]: https://matplotlib.org/tutorials/introductory/pyplot.html
[Matplotlib]: https://matplotlib.org/tutorials/index.html
[LongTailedData]: https://www.statisticshowto.com/long-tail-distribution/
[PerceptuallyUniform]: https://programmingdesignsystems.com/color/perceptually-uniform-color-spaces/
[ColorSchemes]: https://carto.com/carto-colors/
[SkewedData]: https://www.mathsisfun.com/data/skewness.html
[Nonlinear]: https://sciencing.com/non-linear-relationship-10003107.html
[LogNormal]: https://brilliant.org/wiki/log-normal-distribution/