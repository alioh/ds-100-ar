---
title: قواعد البيانات العلائقيه و SQL
show_title: true
chapter_number: 9
chapter_text: الفصل التاسع
chapter_lessons: [[0, 'مقدمة'], [1, 'النموذج العلائقي'], [2, 'SQL'], [3, 'الربط في SQL']]
chapter_sublessons: [
    [],
    ['انظمة قواعد البيانات العلائقيه', 'RDBMS × بانداز'],
    ['تنفيذ اوامر الاستعلام في بانداز' , ['طريقة كتابة اوامر SQL', 'SELECT و FROM', 'WHERE', 'دوال الجمع', 'GROUP BY و HAVING', 'ORDER BY و LIMIT', 'مفهوم SQL'], 'ملخص SQL'],
    ['الربط', ['Join', 'Inner Join', 'Full/Outer Join', 'Left Join', 'Right Join', 'Implicit Inner Join'], 'ربط أكثر من جدول', 'ملخص الربط']
]
layout: default
---

## مقدمة

حتى الآن، قمنا بالتعامل مع بيانات محفوظه في ملفات نصيه على الكمبيوتر. على الرغم من سهولة التعامل مع البيانات ذات الحجم الصغير في التحليل، إلا ان استخدام الملفات النصيه لحفظها يظهر لنا بعض التحديات في حالات كثيره عندما نعمل على بيانات حقيقه.

الكثير من البيانات تم جمعها من قبل أشخاص متعددين، فريق من علماء البيانات مثلاً. اذا تم حفظ البيانات في ملفات نصيه، سيحتاج الفريق لتحميل وارسال البيانات في كل مره يتم التعديل عليها. الملفات النصيه لا توفر طريقة مناسبه لإستعادة ليتم استخدامها بين عدد مختلف من المحللين. هذه المشكله، اضافة إلى مشاكل أخرى، تصعب عمل الملفات النصيه لفريق التحليل او اذا كان حجم البيانات كبيراً.

عادةً ما ننتقل لأنظمة قواعد البيانات العلائقيه (RDBMS) لحفظ البيانات، مثلاً MySQL او PostgreSQL. للعمل على هذه الأنظمة، نستخدم لغة الإستعلام SQL بدلاً من بايثون. في هذا الفصل، سنتحدث عن قواعد البيانات العلائقيه ونتعرف على SQL.

## النموذج العلائقي

**قاعدة البيانات** هي مجموعة مُرتبه من البيانات. في السابق، كانت البيانات محفوظه ومصممه بشكل معين لتفي بغرض ما. مثلاً، شركة طيران قد تقوم بحفظ معلومات رحلة بطريقه مختلفه عن حفظ بنك لمعلومات حساب. في عام 1969، قام تيد كود Ted Codd بتعريف النموذج العلائقي كطريقه عامه لحفظ البيانات. البيانات محفوظه في جداول ثنائية الأبعاد تسمى **علاقات Relations**، تحتوي على ملاحظات معينة في كل صف (عادة ما تعرف بمصفوفات Tuples). كل مصفوفه تحتوي على بعض **السمات Attributes** والتي تصف العلاقات بين الجداول. كل سمه عن علاقه لديها اسم ونوع.

لنأخذ جدول العلاقات التالي `purchases`:

**name**|**product**|**retailer**|**date purchased**
:-----:|:-----:|:-----:|:-----:
Samantha|iPod|Best Buy|03-Jun-16
Timothy|Chromebook|Amazon|08-Jul-16
Jason|Surface Pro|Target|02-Oct-16

في `purchases`، كل صف يصف علاقه بين السمات `name`، `product`، `retailer` و `date purchased`.

*مخطط العلاقات Relation schema* تحتوي على أسماء العواميد، انواع البيانات وقيودها. مثلاً، مخطط جدول `purchases` يحدد ان هناك العواميد `name`، `product`، `retailer` و `date purchased`، ويوضح أيضاً ان كل عامود يحتوي على نص.

جدول العلاقات التالي `prices` يوضح السعر الحالي لمنتجات في اسواق مختلفه:

**retailer**|**product**|**price**
:-----:|:-----:|:-----:
Best Buy|Galaxy S9|719.00
Best Buy|iPod|200.00
Amazon|iPad|450.00
Amazon|Battery pack|24.87
Amazon|Chromebook|249.99
Target|iPod|215.00
Target|Surface Pro|799.00
Target|Google Pixel 2|659.00
Walmart|Chromebook|238.79

الآن يمكننا العودة لكلا الجدولين لتحديد كم دفع كل من Samantha، Timothy، و Jason لمنتجاتهم (لنفترض بقاء الأسعار كما هي في جميع الأسواق والأوقات). معاً، كلا الجدولين يكونا **قاعدة بيانات علائقيه**، والتي هي عباره عن جداول بينها أكثر من علاقه. المخطط لكامل قاعدة البيانات هي مصفوفه تحتوي على جميع مخططات العلاقات في قاعدة البيانات.

### انظمة قواعد البيانات العلائقيه

يمكننا وصف قواعد البيانات العلائقيه بأنها مجموعه من الجداول تحتوي على صفوف لمدخلات. نظام قاعدة بيانات علائقيه (RDBMS) يوفر واجهه للمستخدم لتلك القواعد. [Oracle](https://www.wikiwand.com/en/Oracle_Database)، [MySQL](https://www.wikiwand.com/en/MySQL) و [PostgreSQL](https://www.wikiwand.com/en/PostgreSQL) هي ثلاث من أكثر قواعد البيانات العلائقيه إستخداماً.

توفر هذه الأنظمة المستخدم امكانية إضافة، تعديل، وحذف البيانات منها. إضافة لعدد من المميزات لتميزها عن إستخدام الملفات النصيه لحفظ البيانات، وهي:

- ضمانية حفظ البيانات: تحمي هذه الأنظمة البيانات من مشاكل الأنظمة المختلفه.
- الأداء: تحفظ البيانات بشكل أكثر كفاءة من الملفات النصيه ولديها خوارزميات صُممت بشكل متقن للإستعلام عن البيانات.
- إدارة البيانات: توفر ادوات للتحكم بالوصول للبيانات، للحمايه من المستخدمين غير المصرح لهم بالوصول للبيانات الحساسه.
- تناسق البيانات: يمكن لهذه الأنظمة فرض قيود على المحتوى المُدخل، مثلاً، العامود `GPA` يجب ان يحتوي فقط على رقم عشري من 0.0 حتى 4.0.

للتعامل مع البيانات المحفوظه فيه قواعد RDBMS نستخدم SQL.

### RDBMS × بانداز

ما الفرق بين RDBMS و بانداز؟ أولاً، بانداز لا تعتبر وسيله لحفظ البيانات. على الرغم ان ال DataFrames في بانداز يمكنها الكتابه والقراءة من عدة اشكال للبيانات، لا يمكن لبانداز التحكم بطريقة حفظ البيانات في الكمبيوتر كما في RDBMS. ثانياً، بانداز توفر بشكل اساسي ادوات للتعامل مع البيانات، بينما RDBMS توفر طرق حفظ والتعامل مع البيانات معاً، مما يجعلها خياراً افضل للبيانات ذات الحجم الكبير. من القواعد العامه هي ان نستخدم RDBMS عندنا تكون حجم البيانات لدينا أكثر من عدة قيقا بايت. اخيراً، للتعامل مع بانداز نحتاج لمعرفة ببايثون، بينما في RDBMS نحتاج لمعرفة SQL. وبما ان SQL اسهل بكثير للتعلم من بايثون، مما يجعل RDBMS سهله للتعامل من قبل المستخدمين غير التقنيين.


## SQL

SQL (لغة الاستعلام الهيكلية) هي لغه برمجه لديها عمليات لتحديد، ترتيب، تعديل و إجراء العمليات الحسابيه على بيانات محفوظه في انظمة قواعد البيانات العلائقيه (RDBMS).

تعتبر SQL لغة برمجه تعريفيه. يعني ذلك ان المستخدم يجب ان يحدد اي نوع من البيانات يحتاج *what*، وليس كيف يحصل عليه *how*. للتوضيح:

- **Declarative تعرفيه**: قم بعملية حساب للعامودين `x` و `y` من الجدول `A` عندما تكون القيمة في العامود `y` أكبر من 100.00.
- **Imperative أمريه**: لكل قيمه في الجدول `A`، تحقق أن كانت القيمه للمتغير `y` أكثر من 100. إذا كانت كذلك، احفظ سمات العواميد `x` و `y` في جدول جديد. واظهر لنا الجدول الجديد.

في هذا الفصل، سنكتب استعلامات SQL كنصوص في بايثون، ثم نستخدم بانداز لتنفيذ هذه أوامر الإستعلام وقراءة النتائج ك DataFrame في بانداز. اثناء شرحنا للأوامر في SQL، سنظهر طريقة كتابتها في بانداز للمقارنه بينهما.

### تنفيذ اوامر الاستعلام في بانداز

لتنفيذ اوامر استعلام SQL في بايثون، سنقوم بالتواصل مع قاعدة البيانات بإستخدام مكتبة [sqlalchemy](http://docs.sqlalchemy.org/en/latest/core/tutorial.html). يمكننا لاحقاً إستخدام الدالة [pd.read_sql](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_sql.html) لتنفيذ اوامر SQL.

> لتحميل قاعدة البيانات sql_basics.db [اضغط هنا]({{ site.baseurl }}/files/chapter9/sql_basics.db).

```python
import sqlalchemy

# pd.read_sql يقبل متغير engine يوصلنا بقاعدة البيانات، والذي انشأناه بالأسفل
sqlite_uri = "sqlite:///sql_basics.db"
sqlite_engine = sqlalchemy.create_engine(sqlite_uri)
```

تحتوي قاعدة البيانات على جدول علاقات واحد: `prices`. لإظهاره نستخدم امر استعلام في SQL بإستخدام الداله `read_sql` على قاعدة البيانات العلائقية RDBMS، ثم تأتينا النتيجة ك DataFrame:

```python
sql_expr = """
SELECT * 
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

 ||**retailer**|**product**|**price**
:-----:|:-----:|:-----:|:-----:
0|Best Buy|Galaxy S9|719
1|Best Buy|iPod|200
2|Amazon|iPad|450
3|Amazon|Battery pack|24.87
4|Amazon|Chromebook|249.99
5|Target|iPod|215
6|Target|Surface Pro|799
7|Target|Google Pixel 2|659
8|Walmart|Chromebook|238.79

لاحقاً في هذا الفصل، سنقارن بين استعلامات SQL و دوال بانداز لذا قمنا بكتابة DataFrame تحتوي على نفس المحتوى السابق وحفظناها في المتغير `prices`:

```python
import pandas as pd

prices = pd.DataFrame([['Best Buy', 'Galaxy S9', 719.00],
                   ['Best Buy', 'iPod', 200.00],
                   ['Amazon', 'iPad', 450.00],
                   ['Amazon', 'Battery pack', 24.87],
                   ['Amazon', 'Chromebook', 249.99],
                   ['Target', 'iPod', 215.00],
                   ['Target', 'Surface Pro', 799.00],
                   ['Target', 'Google Pixel 2', 659.00],
                   ['Walmart', 'Chromebook', 238.79]],
                 columns=['retailer', 'product', 'price'])
```

 ||**retailer**|**product**|**price**
:-----:|:-----:|:-----:|:-----:
0|Best Buy|Galaxy S9|719
1|Best Buy|iPod|200
2|Amazon|iPad|450
3|Amazon|Battery pack|24.87
4|Amazon|Chromebook|249.99
5|Target|iPod|215
6|Target|Surface Pro|799
7|Target|Google Pixel 2|659
8|Walmart|Chromebook|238.79

### طريقة كتابة اوامر SQL

جميع اوامر الإستعلام في SQL تكون بهذا الشكل:

```python
SELECT [DISTINCT] <column expression list>
FROM <relation>
[WHERE <predicate>]
[GROUP BY <column list>]
[HAVING <predicate>]
[ORDER BY <column list>]
[LIMIT <number>]
```

لاحظ ان:
- **جميع ما في [داخل الأقواس] هي اوامر إختياريه.** ليكون امر الاستعلام صحيح يجب ان يحتوي على `SELECT` و `FROM`.
- **في العادة تكتب اوامر الأستعلام في SQL بأحرف إنجليزيه كبيره.** على الرغم ان تكبير الأحرف ليس مطلوب، لكن يعتبر من الطرق المتبعه الصحيحه لكتابة الأوامر، لتسهل على المستخدمين الآخرين قراءة استعلاماتك.
- في الأمر `FROM` يمكننا الاستعلام عن اكثر من جدول، ولكن في هذا الفصل سنتدرب على استخدام جدول واحد لجعل الأمر سهلاً على المتعلم.

#### SELECT و FROM

الأمران الألزاميان في استعلامات SQL هي:

- `SELECT` وتعني العواميد التي نريد اظهارها.
- `FROM` ويقصد بها الجداول التي نأخذ منها العواميد.

لعرض جميع محتوى جدول `prices`، نطبق الأمر:

```python
sql_expr = """
SELECT * 
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

 ||**retailer**|**product**|**price**
:-----:|:-----:|:-----:|:-----:
0|Best Buy|Galaxy S9|719
1|Best Buy|iPod|200
2|Amazon|iPad|450
3|Amazon|Battery pack|24.87
4|Amazon|Chromebook|249.99
5|Target|iPod|215
6|Target|Surface Pro|799
7|Target|Google Pixel 2|659
8|Walmart|Chromebook|238.79

الأستعلام `SELECT *` يجلب لنا جميع العواميد. لعرض فقط عامود `retailer`، نقوم بإضافتها كالتالي:

```python
sql_expr = """
SELECT retailer
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

 ||**retailer**|
:-----:|:-----:|
0|Best Buy|
1|Best Buy|
2|Amazon|
3|Amazon|
4|Amazon|
5|Target|
6|Target|
7|Target|
8|Walmart|

اذا اردنا عرض القيم في الجدول بدون تكرار، نقوم بإضافة `DISTINCT`:

```python
sql_expr = """
SELECT DISTINCT(retailer)
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

 ||**retailer**|
:-----:|:-----:|
0|Best Buy|
1|Amazon|
2|Target|
3|Walmart|

طريقة كتابة هذا الإستعلام في بانداز تكون كالتالي:

```python
prices['retailer'].unique()
```

```ruby
array(['Best Buy', 'Amazon', 'Target', 'Walmart'], dtype=object)
```

كل نظام قواعد بيانات يأتي بدوالة الخاصه التي يمكن تطبيقها، مثلاً دوال مقارنه، العمليات الحسابيه، ودوال النصوص. في هذه الماده نستخدم PostgreSQL، نظام قواعد بيانات علائقي ويأتي معه بالكثير من الدوال. يمكن تصفح كامل الدوال [هنا](https://www.postgresql.org/docs/9.2/static/functions.html). تذكر دائماً ان كل نظام لديه دوالة الخاصه.

الإستعلام التالي يحول كل اسماء الأسواق إلى حروف كبيره، ويقوم بقسمة سعر الشراء على 2:

```python
sql_expr = """
SELECT
    UPPER(retailer) AS retailer_caps,
    product,
    price / 2 AS half_price
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

||**retailer\_caps**|**product**|**half\_price**
:-----:|:-----:|:-----:|:-----:
0|BEST BUY|Galaxy S9|359.5
1|BEST BUY|iPod|100
2|AMAZON|iPad|225
3|AMAZON|Battery pack|12.435
4|AMAZON|Chromebook|124.995
5|TARGET|iPod|107.5
6|TARGET|Surface Pro|399.5
7|TARGET|Google Pixel 2|329.5
8|WALMART|Chromebook|119.395

لاحظ ان بإمكاننا استخدام مسميات مستعاره للجداول **Alias** بإستخدام `AS` لكي يظهر العامود بمسمى جديد. لكن هذا لا يغير شئ بإسم العامود الأصلي

#### WHERE

`WHERE` تُمكنا من تحديد شروط معينة للبيانات. مثلاً، اذا اردنا إيجاد فقط المنتجات اقل من $500:

```python
sql_expr = """
SELECT *
FROM prices
WHERE price < 500
"""
pd.read_sql(sql_expr, sqlite_engine)
```

||**retailer**|**product**|**price**
:-----:|:-----:|:-----:|:-----:
0|Best Buy|iPod|200
1|Amazon|iPad|450
2|Amazon|Battery pack|24.87
3|Amazon|Chromebook|249.99
4|Target|iPod|215
5|Walmart|Chromebook|238.79

يمكننا إيضاً استخدام `AND`، `OR` و `NOT` لتحديد استعلامنا بشكل ادق. مثلاً، للبحث عن منتجات Amazon والتي لا تحتوي على Battery pack وسعرها اقل من $300، نكتب الإستعلام التالي:

```python
sql_expr = """
SELECT *
FROM prices
WHERE retailer = 'Amazon'
    AND NOT product = 'Battery pack'
    AND price < 300
"""
pd.read_sql(sql_expr, sqlite_engine)
```

||**retailer**|**product**|**price**
:-----:|:-----:|:-----:|:-----:
0|Amazon|Chromebook|249.99

ولكتابة نفس الأمر في بانداز:

```python
prices[(prices['retailer'] == 'Amazon') 
   & ~(prices['product'] == 'Battery pack')
   & (prices['price'] <= 300)]
```

||**retailer**|**product**|**price**
:-----:|:-----:|:-----:|:-----:
4|Amazon|Chromebook|249.99

نلاحظ هناك وجود فرق يجب التنبيه عنه، الرقم التسلسلي للمنتجى Chromebook في استعلام SQL كان 0، ولكن في استعلام بايثون 4. هذا لأن استعلامات SQL تقوم دائماً بعرض البيانات في جدول جديد وبأرقام تسلسليه جديده تبدأ من 0، ولكن في بانداز، تقوم بعرض جزء من ال DataFrame مع استخدام نفس ارقام التسلسل. يمكننا استخدام الدالة [pd.DataFrame.reset_index](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.reset_index.html) لإعادة تعين الأرقام التسلسليه في بانداز.

#### دوال الجمع

حتى الآن، تعاملنا مع بيانات موجوده في الجداول، يعني ذلك، كل النتائج التي ظهرت سابقاً هي اجزاء من المدخلات في الجداول. ولكن لتطبيق تحليل للبيانات، نحتاج للقيام ببعض عمليات التجميع على بياناتنا. في SQL، يطلق عليها **دوال التجميل Aggregate Functions**.

لنوجد قيمة متوسط اسعار جميع المنتجات في جدول `prices`:

```python
sql_expr = """
SELECT AVG(price) AS avg_price
FROM prices
"""
pd.read_sql(sql_expr, sqlite_engine)
```

||**avg\_price**
:-----:|:-----:
0|395.072222

وفي بانداز نكتبها:

```python
prices['price'].mean()
```

```ruby
395.0722222222222
```

قائمة كاملة بجميع دوال التجميع في PostgreSQL [هنا](https://www.postgresql.org/docs/9.2/static/functions.html). على الرقم من اننا نستخدمها كاداة اساسيه للتعامل مع SQL في هذه الماده، تذكر ان هناك انواع مختلفه من SQL مثل MySQL، SQLite وغيرها التي تستخدم اسماء مختلفه للدوال وبعض الأحيان تحتوي على دوال مختلفه.

#### GROUP BY و HAVING

#### ORDER BY و LIMIT

#### مفهوم SQL

### ملخص SQL

## الربط في SQL

### الربط

#### Inner Join

#### Full/Outer Join

#### Left Join

#### Right Join

#### Implicit Inner Join

### ربط أكثر من جدول

### ملخص الربط