---
title: التعامل مع النصوص
show_title: true
chapter_number: 8
chapter_text: الفصل الثامن
chapter_lessons: [[0, 'مقدمة'], [1, 'دوال النصوص في بايثون'], [2, 'التعابير النمطية RegEx'], [3, 'التعابير النمطية في بايثون وبانداز']]
chapter_sublessons: [
    [],
    ['دوال النصوص في بايثون', 'تنظيف البيانات النصية', 'دوال النصوص', 'دوال النصوص في بانداز', 'ملخص دوال النصوص'],
    [['كتابة أوامر التعابير النمطية', 'حرفياً', 'رموز خاصة', 'المجموعات النصية', 'عكس المجموعات النصية', 'الحدود الرقمية', 'تحديد المكان', 'تجاهل الرموز الخاصة'], 'مرجع التعابير النمطية', 'ملخص التعابير النمطية RegEx'],
    ['RE.SEARCH', 'RE.FINDALL', 'مجموعات RegEx', 'RE.SUB', 'RE.SPLIT', 'التعابير النمطية و بانداز', 'ملخص التعابير النمطية في بايثون وبانداز']
]
layout: default
---

## مقدمة

الكثير من البيانات التي نواجهها في ملف CSV ليست أرقام بس نصوص موجودة في كُتب، ملفات، تدوينات، أو تعليقات في الإنترنت. كما في الكثير من أنواع البيانات، هناك طرق مختلفة للتعامل مع النصوص وقد نحتاج لكتابة أكثر من كتاب لشرحها بشكل تفصيلي. في هذا الفصل، سنشرح جزء بسيط من هذه التقنيات والتي توفر لنا العديد من العمليات المفيدة للعمل مع النصوص: معالجة نصوص بايثون والتعابير النمطية RegEx.

## دوال النصوص في بايثون

توفر لنا بايثون العديد من الدوال للتعامل مع النصوص. رغم بساطتها، تعد هذه الدوال من الأولويات في التعامل مع النصوص والتي جُمعت مع بعضها البعض لتكون دوال أكثر تعقيداً. سنقوم بشرح دوال بايثون للتعامل مع النصوص حسب كثرة الاستخدام في تنظيف البيانات النصية.

### تنظيف البيانات النصية

تأتي البيانات عادةً من عدة مصادر وكل مصدر لديه طريقه مختلفة لترميز المعلومات. في المثال التالي، لدينا جدول يحتوي على الولايات الأمريكية والمقاطعات التي تشملها وجدول آخر يحتوي على عدد سكان المقاطعة.

```python
state = pd.DataFrame({
    'County': [
        'De Witt County',
        'Lac qui Parle County',
        'Lewis and Clark County',
        'St John the Baptist Parish',
    ],
    'State': [
        'IL',
        'MN',
        'MT',
        'LA',
    ]
})
population = pd.DataFrame({
    'County': [
        'DeWitt  ',
        'Lac Qui Parle',
        'Lewis & Clark',
        'St. John the Baptist',
    ],
    'Population': [
        '16,798',
        '8,067',
        '55,716',
        '43,044',
    ]
})
```

**State**|**County**| 
:-----:|:-----:|:-----:
IL|De Witt County|0
MN|Lac qui Parle County|1
MT|Lewis and Clark County|2
LA|St John the Baptist Parish|3

<br>

**Population**|**County**| 
:-----:|:-----:|:-----:
16,798|DeWitt|0
8,067|Lac Qui Parle|1
55,716|Lewis & Clark|2
43,044|St. John the Baptist|3

بالطبع نريد جمع جدولي `state` و `population` معاً باستخدام العمود `County`. للأسف، لا تتطابق أي من أسماء المقاطعات في الجدولين. هذا المثال يوضح عدد من المشاكل في البيانات النصية وهي كالتالي:

- الكتابة بحروف كبيرة / صغيرة: `qui` و `Qui`
- علامات ترقيم مختلفة: `St. ` و `St`
- عدم كتابة بعض الكلمات: مثلاً كلمتي `County`/`Parish` لم يتم كتابتها في جدول `population`.
- إضافة مسافات: `DeWitt` و `De Witt`.
- استخدام مُختلف للاختصارات: `&` و `and`.

### دوال النصوص

دوال النصوص في بايثون تساعدنا بالبدء في حل هذه المشاكل. هذه الدوال مُعرّفه في جميع نسخ بايثون لذا لا نحتاج لإستخادم اي مكتبه أخرى. على الرغم أنه مهم جداً لك شخصياً معرفة [جميع الدوال للتعامل مع النصوص](https://docs.python.org/3/library/stdtypes.html#string-methods)، قمنا بشرح بعض من أكثر الدوال استخداماً في الجدول التالي:

**الدالة**|**الوصف**
:-----:|:-----:
str[x:y]| تقوم الداله بفصل النص `str` من `x` (تشمل الحرف) حتى `y` (لا تشمل الحرف). 
()str.lower| تنشئ نسخه من النص `str` بعد تحويل جميع الحروف فيه إلى حروف صغيره. 
str.replace(a, b)| تحويل جميع مرات ظهور النص/الحرف `a` في  `str` إلى النص/الحرف `b`. 
str.split(a)| تقوم الدالة بفصل النص `str` عند ظهور النص/الحرف `a`. 
()str.strip| تحذف الداله المسافات الفارغه في بداية ونهاية النص `str` 

قمنا باختيار النص `St. John the Baptist` من جدولي `state` و `population` لتطبيق دوال النصوص بحذف الحروف الكبيرة، علامات الترقيم، والتخلص من الكلمتين `county` و `parish`:

```python
john1 = state.loc[3, 'County']
john2 = population.loc[3, 'County']

(john1
 .lower()
 .strip()
 .replace(' parish', '')
 .replace(' county', '')
 .replace('&', 'and')
 .replace('.', '')
 .replace(' ', '')
)
```

```ruby
'stjohnthebaptist'
```

تطبيق نفس الدوال على `john2` يؤكد لنا أن النصين مُتطابقان:

```python
(john2
 .lower()
 .strip()
 .replace(' parish', '')
 .replace(' county', '')
 .replace('&', 'and')
 .replace('.', '')
 .replace(' ', '')
)
```

```ruby
'stjohnthebaptist'
```

عند الوصول لنتيجة مُقنعه، نقوم بتعريف دالة باسم `clean_county` والتي ستطبق مهام تنظيف المدخلات (المقاطعات):

```python
def clean_county(county):
    return (county
            .lower()
            .strip()
            .replace(' county', '')
            .replace(' parish', '')
            .replace('&', 'and')
            .replace(' ', '')
            .replace('.', ''))
```

يمكننا التأكد أن الدالة `clean_county` تقوم بتوحيد جميع أسماء المقاطعات عبر تطبيقها على الجدولين:

```python
([clean_county(county) for county in state['County']],
 [clean_county(county) for county in population['County']]
)
```

```ruby
(['dewitt', 'lacquiparle', 'lewisandclark', 'stjohnthebaptist'],
 ['dewitt', 'lacquiparle', 'lewisandclark', 'stjohnthebaptist'])
```

بما أن كلا العامودين الآن يحتويان على نفس اسم المقاطعة وبنفس الشكل، يمكننا جمع الجدولين معاً باستخدام اسم المقاطعة.

### دوال النصوص في بانداز

في الكود البرمجي السابق، استخدمنا التكرار Loop لتغير أسماء المقاطعات. مصفوفات `pandas` تقدم طريقة أسهل لتطبيق دوال النصوص لجميع محتوى المصفوفة. أولا، لنرى أسماء المقاطعات في جدول `state`:

```python
state['County']
```

```ruby
0                De Witt County
1          Lac qui Parle County
2        Lewis and Clark County
3    St John the Baptist Parish
Name: County, dtype: object
```

الدالة `.str` في مصفوفات بانداز تتعامل مع النص كما في بايثون. استخدام الدوال على `.str` يطبقها على جميع القيم في المصفوفة:

```python
state['County'].str.lower()
```

```ruby
0                de witt county
1          lac qui parle county
2        lewis and clark county
3    st john the baptist parish
Name: County, dtype: object
```

يُمكنا ذلك من تحويل جميع النصوص في المصفوفة دون الحاجة لاستخدام التكرار:

```python
(state['County']
 .str.lower()
 .str.strip()
 .str.replace(' parish', '')
 .str.replace(' county', '')
 .str.replace('&', 'and')
 .str.replace('.', '')
 .str.replace(' ', '')
)
```

```ruby
0              dewitt
1         lacquiparle
2       lewisandclark
3    stjohnthebaptist
Name: County, dtype: object
```

نعيد حفظ نتيجة تغير شكل عمود المقاطعات على نفس العمود:

```python
state['County'] = (state['County']
 .str.lower()
 .str.strip()
 .str.replace(' parish', '')
 .str.replace(' county', '')
 .str.replace('&', 'and')
 .str.replace('.', '')
 .str.replace(' ', '')
)

population['County'] = (population['County']
 .str.lower()
 .str.strip()
 .str.replace(' parish', '')
 .str.replace(' county', '')
 .str.replace('&', 'and')
 .str.replace('.', '')
 .str.replace(' ', '')
)
```

والآن بما أن كلا الجدولين لديهما نفس التعبير النصي للمقاطعات:

```python
state
```

**State**|**County**| 
:-----:|:-----:|:-----:
IL|dewitt|0
MN|lacquiparle|1
MT|lewisandclark|2
LA|stjohnthebaptist|3

```python
population
```

**Population**|**County**| 
:-----:|:-----:|:-----:
16,798|dewitt|0
8,067|lacquiparle|1
55,716|lewisandclark|2
43,044|stjohnthebaptist|3

من السهل جمع الجدولين عندما يتطابق عمود المناطق:

```python
state.merge(population, on='County')
```

**Population**|**State**|**County**| 
:-----:|:-----:|:-----:|:-----:
16,798|IL|dewitt|0
8,067|MN|lacquiparle|1
55,716|MT|lewisandclark|2
43,044|LA|stjohnthebaptist|3

### ملخص دوال النصوص

توفر بايثون دوال سهله وعملية للتعامل وتعديل النصوص. مصفوفات بانداز توفر نفس الدوال وتسهل تطبيقها على جميع القيم داخل المصفوفة.

يمكنك تصفح شرح كامل عن دوال النصوص في بايثون [هنا](https://docs.python.org/3/library/stdtypes.html#string-methods) ودوال النصوص في بانداز [هنا](https://pandas.pydata.org/pandas-docs/stable/text.html#method-summary)

## التعابير النمطية RegEx

في هذا الجزء سنتحدث عن التعابير النمطية RegEx، أداة مهمة للتحقق من الأنماط في النصوص.

في النصوص الكبيرة، الكثير من النصوص الفرعية تأتي بعدة أشكال. مثلاً، الجملة في الأسفل تحتوي على رقم هاتف:

```ruby
"give me a call, my number is 123-456-7890."
```

رقم الهاتف يحتوي على الأنماط التالية:
- ثلاث أرقام.
- متبوعه بخط فاصل.
- متبوعه بثلاث أرقام.
- متبوعه بخط فاصل.
- متبوعه بأربع أرقام.

إذا أعطينا نصاً مكتوب، قد نرغب بإيجاد وسحب أرقام الهواتف فقط. رُبَّمَا أيضا نريد جزء معين من رقم الهاتف، مثلاً، سحب رمز المنطقة (الثلاث أرقام الأولى) قد يوصل لنا مكان تواجد صاحب الرقم المذكور في النص.

للتحقق إذا كان النص يحتوي على رقم هاتف، قد نعرف دالة كالتالي:

```python
def is_phone_number(string):
    
    digits = '0123456789'
    
    def is_not_digit(token):
        return token not in digits 
    
    # ثلاث ارقام
    for i in range(3):
        if is_not_digit(string[i]):
            return False
    
    # متبوعه بخط فاصل
    if string[3] != '-':
        return False
    
    # متبوعه بثلاث ارقام
    for i in range(4, 7):
        if is_not_digit(string[i]):
            return False
        
    # متبوعه بخط فاصل   
    if string[7] != '-':
        return False
    
    # متبوعه بأربع ارقام
    for i in range(8, 12):
        if is_not_digit(string[i]):
            return False
    
    return True
```

وللتحقق:

```python
is_phone_number("382-384-3840")
```

```ruby
True
```

```python
is_phone_number("phone number")
```

```ruby
False
```

الكود البرمجي السابق يبدو طويل وغير مرغوب فيه. بدلاً من الدوران على كل الحروف في النص، نفضل أن نحدد النمط وأوامر لبايثون تسهل علينا إيجاد الأنماط المطابقة لطلباتنا.

**التعابير النمطية Regular expressions** (وبشكل مختصر **RegEx**) تحل هذه المشكلة بجعلنا ننشأ الأنماط للنصوص. باستخدامها، يمكننا إعادة تعريف الدالة السابقة `is_phone_number` بسطرين في بايثون:

```python
import re

def is_phone_number(string):
    regex = r"[0-9]{3}-[0-9]{3}-[0-9]{4}"
    return re.search(regex, string) is not None

is_phone_number("382-384-3840")
```

```ruby
True
```

في المثال السابق، استخدمنا التعبير النمطي `[0-9]{3}-[0-9]{3}-[0-9]{4}` لمطابقة أرقام الهواتف. ربما يبدو مبهماً في البداية، ولكن أوامر التعابير النمطية سهلة للتعلم؛ في هذا الجزء شرحنا كل الأوامر.

سنقوم بالتعرف على المكتبه التي تأتي مع بايثون بأسم `re` الخاصه بكتابة وتطبيق عمليات النصوص بإستخدام التعابير النمطية.

### كتابة أوامر التعابير النمطية

سنبدأ أولاً بالتعرف على طريقة الكتابه. التعابير النمطية عادةً ما تُحفظ على شكل نصوص خام Raw String. تعمل تماماً كما تعمل النصوص في بايثون ولكن دون قوانين خاصة للخطوط المائله `\`.

> الخط المائل `\` يستخدم لتجاهل ما بعدهEscape. مثلاً، اذا اردنا كتابة `It's raining`، نحتاج لإضافة `\` قبل `'` لأن علامة الإقتباس تستخدم لحفظ النص:
> ```python
> print('It\'s raining')
> ```
>
> ```ruby
> It's raining 
> ```
>
> تستخدم ايضاً `\` لإضافة سطر جديد باستخدام `n\` أو اضافة مسافة باستخدام `t\`

مثلاً لحفظ النص `hello \ world` في بايثون، نحتاج لكتابة:

```python
# الخطوط المائلة في بايثون تحتاج للتوضيح ليتم تجاهلها في نصوص بايثون العاديه
some_string = 'hello \\ world'
print(some_string)
```

```ruby
hello \ world
```

استخدام النصوص الخامة يحذف شرط إضافة رمز لتجاهل الخطوط المائلة:

> لإخبار بايثون أن النص التالي يعتبر نص خام Raw String, نقوم بإضافة r قبل النص

```python
# لاحظ ال `r` قبل بداية النص
some_raw_string = r'hello \ world'
print(some_raw_string)
```

```ruby
hello \ world
```

بما ان الخطوط المائلة تظهر بشكل كثير في التعابير النمطية، سنستخدم النصوص الخامة لكتابة جميع التعابير النمطية في هذا الجزء.

#### حرفياً

إيجاد حرف بشكل معين بالتحديد في التعبير النمطي يوجد لنا ذلك الحرف فقط. مثلاً، التعبير `"r"a` يوجد لنا أي `"a"` في `Say! I like green eggs and ham!`. جميع الأرقام والأحرف ورموز الترقيم يمكن البحث عنها بشكل خاص في التعابير النمطية:

```python
def show_regex_match(text, regex):
    """
    تطبع النص مع تغير اللون لتحديد نمط regex
    """
    print(re.sub(f'({regex})', r'\033[1;30;43m\1\033[m', text))
```

```python
regex = r"green"
show_regex_match("Say! I like green eggs and ham!", regex)
```

<div class="regex">
<pre class="highlight">
Say! I like <span>green</span> eggs and ham!
</pre>
</div>

```python
show_regex_match("Say! I like green eggs and ham!", r"a")
```

<div class="regex">
<pre class="highlight">
S<span>a</span>y! I like green eggs <span>a</span>nd h<span>a</span>m!
</pre>
</div>

في المثال السابق، شاهدنا أن التعابير النمطية يمكنها إيجاد الأنماط أينما ظهر في النص المدخل. في بايثون، في بايثون هذه الطريقة تختلف بِنَاءَا على الدالة المدخلة لمطابقة التعبير النمطي، بعض الدوال فقط تظهر النتيجة إذا ظهر في بداية النص، والبعض يظهرها إذا ظهرت في أي مكان في النص.

لاحظ أيضا أن الدالة `show_regex_match` تظهر جميع تكرارات النمط في النص المدخل. مرة أخرى، يختلف ذلك حسب دالة بايثون المستخدمة، بعضها يظهر جميع التكرارات والبعض فقط يظهر أول تكرار.

التعابير النمطية تتحسس لحالة وشكل الحرف. في المثال التالي، التعبير يطابق فقط الحرف الصغير `s` في `eggs`، وليس الحرف الكبير `S` في `Say`.

```python
show_regex_match("Say! I like green eggs and ham!", r"s")
```

<div class="regex">
<pre class="highlight">
Say! I like green egg<span>s</span> and ham!
</pre>
</div>

#### رموز خاصة

بعض الرموز لديها معاني خاصة في RegEx. هذه الرموز تساعدنا على إيجاد أنماط مختلفة من النصوص.

الرمز ` ` (نقطة) تعني أنه تطابق أي حرف عدى أن يكون ببداية سطر جديد:

```python
show_regex_match("Call me at 382-384-3840.", r".all")
```

<div class="regex">
<pre class="highlight">
<span>Call</span> me at 382-384-3840.
</pre>
</div>

لنطابق النقطة بشكل خاص يجب علينا تجاهلها كرمز بإضافة `\`:

```python
show_regex_match("Call me at 382-384-3840.", r"\.")
```

<div class="regex">
<pre class="highlight">
Call me at 382-384-3840<span>.</span>
</pre>
</div>

باستخدام النقطة يمكننا مطابقة أنواع مختلفة من الأنماط، سنقوم بكتابة تعبير نمطي لمطابقة أرقام الهواتف. مثلاً، يمكنا أخذ الرقم `382-384-3840` وتبديل كل رقم بنقطة `.`، لتبقى لنا فقط الخطوط الفاصلة. النتيجة كالتالي `...-...-....`:

```python
show_regex_match("Call me at 382-384-3840.", "...-...-....")
```

<div class="regex">
<pre class="highlight">
Call me at <span>382-384-3840</span>.
</pre>
</div>

بما أن النقطة تطابق جميع النصوص، النص التالي سيظهر لنا نتيجة خاطئة، لأننا نريد إيجاد الأرقام فقط وليس الحروف:

```python
show_regex_match("My truck is not-all-blue.", "...-...-....")
```

<div class="regex">
<pre class="highlight">
My truck is <span>not-all-blue</span>.
</pre>
</div>

#### المجموعات النصية

تسمح لنا المجموعات النصية بمطابقة نوع معين من النصوص، يوفر لنا ذلك إمكانية إنشاء قيود أكثر للتطابق بدلاً من النقطه `.` لمطابقة أي نص. لإنشاء مجموعة، قم بإضافة الحروف داخل أقواس `[ ]`:

```python
show_regex_match("I like your gray shirt.", "gr[ae]y")
```

<div class="regex">
<pre class="highlight">
I like your <span>gray</span> shirt.
</pre>
</div>

```python
show_regex_match("I like your grey shirt.", "gr[ae]y")
```

<div class="regex">
<pre class="highlight">
I like your <span>grey</span> shirt.
</pre>
</div>

```python
# لا يطابق، المجموعات تطابق حرف واحد فقط من ما تحتويها وليس جميعها
show_regex_match("I like your graey shirt.", "gr[ae]y")
```

<div class="regex">
<pre class="highlight">
I like your graey shirt.
</pre>
</div>

```python
# في هذا المثال، كتابة المجموعه مره اخرى ستطابقها
show_regex_match("I like your graey shirt.", "gr[ae][ae]y")
```

<div class="regex">
<pre class="highlight">
I like your <span>graey</span> shirt.
</pre>
</div>

في مجموعات النصوص، الرمز `.` سيتخدم كحرف وليس كرمز:

```python
show_regex_match("I like your grey shirt.", "irt[.]")
```

<div class="regex">
<pre class="highlight">
I like your grey sh<span>irt.</span>
</pre>
</div>

توجد بعض الحالات المختصرة الخاصة التي يمكن استخدامها لمطابقة مجموعات النصوص:

**الإختصار**|**المعنى**
:-----:|:-----:
[0-9]|جميع الارقام
[a-z]|الأحرف الصغيره
[A-Z]|الأحرف الكبيره

<br>

```python
show_regex_match("I like your gray shirt.", "y[a-z]y")
```

```ruby
I like your gray shirt.
```

تُمكنا المجموعات النصية من إنشاء أنماط خاصة بأرقام الهواتف:

```python
# استبدلنا النقاط `.` في ...-...-.... ب [0-9] لتحديد النمط على الأرقام
phone_regex = r'[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]'
show_regex_match("Call me at 382-384-3840.", phone_regex)
```

<div class="regex">
<pre class="highlight">
Call me at <span>382-384-3840</span>.
</pre>
</div>

```python
# والآن لا نطابق هذا النص
show_regex_match("My truck is not-all-blue.", phone_regex)
```

```ruby
My truck is not-all-blue.
```

#### عكس المجموعات النصية

عكس المجموعات يطابق أي نص غير الموجود في المجموعة. لإنشاء هذا التعبير، نضيف النص داخل الأقواس `[^ ]`:

```python
show_regex_match("The car parked in the garage.", r"[^c]ar")
```

<div class="regex">
<pre class="highlight">
The car <span>par</span>ked in the <span>gar</span>age.
</pre>
</div>

#### الحدود الرقمية

لإنشاء تعبير نمطي لمطابقة أرقام الهواتف، كتبنا التالي:

```python
[0-9][0-9][0-9]-[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]
```

هذا النمط يطابق ثلاثة أرقام، متبوعه بخط، ثم ثلاثة أرقام وخط ثم أربعة أرقام أخرى.

الحدود الرقمية تسمح لنا مطابقة التكرار في النمط. نحدد عدد مرات التكرار بوضع الرقم داخل أقواس معقوفة `{ }`:

```python
phone_regex = r'[0-9]{3}-[0-9]{3}-[0-9]{4}'
show_regex_match("Call me at 382-384-3840.", phone_regex)
```

<div class="regex">
<pre class="highlight">
Call me at <span>382-384-3840</span>.
</pre>
</div>

```python
# لا تطابق لأن اول جزء مكون من رقمين
phone_regex = r'[0-9]{3}-[0-9]{3}-[0-9]{4}'
show_regex_match("Call me at 12-384-3840.", phone_regex)
```

```ruby
Call me at 12-384-3840.
```

الحدود تطابق جميع النصوص أو الفئات النصية التي كُتبت قبلها. الجدول التالي يظهر شرح لها:

**رمز الحدود الرقمية**|**المعنى**
:-----:|:-----:
{m, n}|مطابقة تكرار الحرف من m إلى n مرات.
{m}|مطابقة تكرار الحرف m مرات.
{m,}|مطابقة تكرار الحرف على الأقل m مرات.
{,n}|مطابقة تكرار الحرف بالأكثر n مرات.

##### اختصارات الحدود الرقمية

الكثير من الحدود الرقمية التي تستخدم كثيراً تم اختصارها:

**الرمز**|**رمز الحدود الرقمية المفصل**|**المعنى**
:-----:|:-----:|:-----:
*|{0,}|مطابقة تكرار الحرف 0 أو أكثر.
+|{1,}|مطابقة تكرار الحرف مرة واحدة أو أكثر.
?|{0,1}|مطابقة تكرار الحرف 0 أو مرة واحدة.

نستخدم الرمز `*` بدلاً من `{0,}` في الأمثلة التالية:

```python
# تكرار a ثلاث مررات
show_regex_match('He screamed "Aaaah!" as the cart took a plunge.', "Aa*h!")
```

<div class="regex">
<pre class="highlight">
He screamed "<span>Aaaah!</span>" as the cart took a plunge.
</pre>
</div>

```python
# مطابقة المزيد من a
show_regex_match(
    'He screamed "Aaaaaaaaaaaaaaaaaaaah!" as the cart took a plunge.',
    "Aa*h!"
)
```

<div class="regex">
<pre class="highlight">
He screamed "<span>Aaaaaaaaaaaaaaaaaaaah!</span>" as the cart took a plunge.
</pre>
</div>

```python
# عدم وجود a بشكل صغير
show_regex_match('He screamed "Ah!" as the cart took a plunge.', "Aa*h!")
```

<div class="regex">
<pre class="highlight">
He screamed "<span>Ah!</span>" as the cart took a plunge.
</pre>
</div>

##### الحدود الكمية جشعه!

توجد لنا دائماً الحدود الكمية أكثر القيم تطابقاً. تظهر بعض المرات نتائج غير متوقعة:

```python
# حاولنا إيجاد 311 و 911 ولكن تم ايجاد and ايضاً
# لأن
# <311> and <911>
# هي اعلى قيمه ممكنه للنمط <.+>
show_regex_match("Remember the numbers <311> and <911>", "<.+>")
```

<div class="regex">
<pre class="highlight">
Remember the numbers <span><311> and <911></span>
</pre>
</div>

> في هذا المثال نلاحظ أن التعبير النمطي لم يتوقف عند أول ظهور ل `>` بس أستمر إلى آخر تكرار، يقصد هنا أن الحدود الكمية تبحث دائماً عن المزيد ولا تتوقف عند تكرار واحد إلا إذا حددنا ذلك

في كثير من الحالات، استخدام مجموعات النصوص يسهل علينا تفادي هذه النتائج الخاطئة:

```python
show_regex_match("Remember the numbers <311> and <911>", "<[0-9]+>")
```

<div class="regex">
<pre class="highlight">
Remember the numbers <span><311></span> and <span><911></span>
</pre>
</div>

#### تحديد المكان

في بعض الأحيان نريد أن يتطابق النمط إذا كان في بداية أو نهاية النص. الرمز الخاص `^` يجعل التعبير يطابق النمط عندما يظهر في بداية النص فقط؛ والرمز الآخر الخاص `$` يطابق النمط إذا ظهر في نهاية النص. مثلاً التعبير النمطي `well$` فقط يطابق ظهور كلمة `well` في نهاية النص:

```python
show_regex_match('well, well, well', r"well$")
```

<div class="regex">
<pre class="highlight">
well, well, <span>well</span>
</pre>
</div>

باستخدام كلا الرمزين `^` و `$` يجعل التعبير يطابق النمط كاملاً:

```python
phone_regex = r"^[0-9]{3}-[0-9]{3}-[0-9]{4}$"
show_regex_match('382-384-3840', phone_regex)
```

<div class="regex">
<pre class="highlight">
<span>382-384-3840</span>
</pre>
</div>

```python
# لا يطابق
# لأنه يبدأ بنص وليس ثلاثة أرقام
# وينتهي بنقطة وليس اربع ارقام
show_regex_match('You can call me at 382-384-3840.', phone_regex)
```

```ruby
You can call me at 382-384-3840.
```

#### تجاهل الرموز الخاصة

كل الرموز الخاصة لها وظائف معينة في التعبير النمطي. ولمطابقة أحد هذه الرموز، يمكننا تجاهل وظيفتها في التعبير النمطي باستخدام `\`:

```python
show_regex_match("Call me at [382-384-3840].", "\[")
```

<div class="regex">
<pre class="highlight">
Call me at <span>[</span>382-384-3840].
</pre>
</div>


```python
show_regex_match("Call me at [382-384-3840].", "\.")
```

<div class="regex">
<pre class="highlight">
Call me at [382-384-3840]<span>.</span>
</pre>
</div>

### مرجع التعابير النمطية

قمنا بالحديث عن أهم النقاط والرموز في التعابير النمطية. ليكون لدينا مرجع كامل، أضفنا الجدول التالي.

#### مرجع الرموز الخاصة

هذا الجدول يحتوي على أهم الرموز الخاصة، والتي تساعدك على تحديد أنماط محددة تريد مطابقتها والبحث عنها في النصوص:


**الرمز**|**الوصف**|**مثال التعبير النمطي**|**يطابق**|**لا يطابق**
:-----:|:-----:|:-----:|:-----:|:-----:
.|يطابق أي حرف عدا سطر جديد|...|abc|ab
 | | | |abcd
[ ]|أي حرف داخل الأقواس|<span style='font-size:1px'>a</span>[cb.]ar|car|jar
 | | |.ar| 
[^ ]|أي حرف غير ما داخل الأقواس|<span style='font-size:1px'>a</span>[^b]ar|car|bar
 | | |par|ar
*|صفر أو أكثر تكرار لما يسبق الرمز|<span style='font-size:1px'>a</span>[pb]*ark|bbark|dark
 | | |ark| 
+|واحد أو أكثر تكرار لما يسبق الرمز|<span style='font-size:1px'>a</span>[pb]+ark|bbpark|dark
 | | |bark|ark
?|صفر أو مرة واحد تكرار لما يسبق الرمز|s?he|she|the
 | | |he| 
{n}|مطابقة عدد مرات التكرار n|hello{3}|hellooo|hello
\| |مطابقة أي نمط بين خيارين|we\|[ui]s|we|e
 | | |us|s
 | | |is| 
\\ |تجاهل الرموز الخاصة|	[\\hi]\\ |[hi]|hi
^|بداية السطر|<span style='font-size:1px'>a</span>^ark|ark two|dark
$|نهاية السطر|$<span style='font-size:1px'>a</span>ark|noahs ark|noahs arks

#### مرجع الاختصارات

بعض من الفئات المختصرة:

**الرمز المختصر**|**التعبير النمطي الكامل للفئة**|**الوصف**
:-----:|:-----:|:-----:
<span style='font-size:1px'>a</span>\w|[a-zA-Z0-9]|أي حرف صغير/كبير أو رقم
<span style='font-size:1px'>a</span>\W|<span style='font-size:1px'>a</span>[^a-zA-Z0-9]|غير أي حرف صغير/كبير أو رقم
<span style='font-size:1px'>a</span>\d|[0-9]|ارقام
<span style='font-size:1px'>a</span>\D|<span style='font-size:1px'>a</span>[^0-9]|غير الأرقام
<span style='font-size:1px'>a</span>\s|<span style='font-size:1px'>a</span>[\t\n\f\r\p{Z}]|المسافات
<span style='font-size:1px'>a</span>\S|<span style='font-size:1px'>a</span>[^\t\n\f\r\p{z}]|غير المسافات

#### ملخص التعابير النمطية RegEx

في جميع لغات البرمجة توجد مكاتب خاصة لمطابقة الأنماط باستخدام التعابير النمطية، مما يجعلها مهمة مع اختلاف اللغات. في هذا الجزء، تحدثنا عن طريقة كتابة التعابير النمطية واهم الرموز المستخدمة.

## التعابير النمطية في بايثون وبانداز

في هذا الجزء، سنتعرف على استخدام مكتبة `re` التعامل مع التعابير النمطية في بايثون. بما أننا تحدثنا على جزء بسيط من أكثر الدوال المستخدمة، يمكنك العودة دائماً إلى [الصفحة الرئيسية لشرح مكتبة `re`](https://docs.python.org/3/library/re.html).

### RE.SEARCH

الدالة `re.search(pattern, string)` تطابق جميع الأنماط داخل المتغير `pattern` في النص `string`. يكون نتيجة الدالة أما النص إذا وجد تطابق أو `None` إن لم يجد:

```python
phone_re = r"[0-9]{3}-[0-9]{3}-[0-9]{4}"
text  = "Call me at 382-384-3840."
match = re.search(phone_re, text)
match
```

```ruby
<_sre.SRE_Match object; span=(11, 23), match='382-384-3840'>
```

عل الرغم أن الكائن الذي أنشئ نتيجة لعملية البحث يحتوي على الكثير من الخصائص المفيدة، نحن عادةً نستخدم `re.search` للاختبار والتأكد في حال ظهور النمط في النص:

```python
if re.search(phone_re, text):
    print("Found a match!")
```

```ruby
Found a match!
```

```python
if re.search(phone_re, 'Hello world'):
    print("No match; this won't print")
```

دالة أخرى كثيره الاستخدام هي `re.match(pattern, string)` وتعمل بنفس طريقة عمل `re.search` ولكن تقوم بالبحث عن تطابق فقط في بداية النص `string` وليس في أي جزء آخر منه.

### RE.FINDALL

نستخدم الدالة `re.findall(pattern, string)` لإيجاد جميع النتائج التي تطابق النمط. هذه الدالة تنتج لنا مصفوفة تحتوي على جميع المطابقات للنمط الذي يكتب في المتغير `pattern` في النص الذي يكتب في المتغير `string`:


```python
gmail_re = r'[a-zA-Z0-9]+@gmail\.com'
text = '''
From: email1@gmail.com
To: email2@yahoo.com and email3@gmail.com
'''
re.findall(gmail_re, text)
```

```ruby
['email1@gmail.com', 'email3@gmail.com']
```

### مجموعات RegEx

استخدام مجموعات RegEx يسمح لنا بمطابقة أنماط متعددة واستخراجها منفصله عن طريق إضافتها داخل أقواس `( )`. عندما يحتوي التعبير النمطي على مجموعات، الدالة `re. findall` تنتج لنا مصفوفة Tuple تحتوي على نتيجة النمط مفصله.

مثلاً، التعبير النمطي التالي يستخرج أرقام الهواتف من النص:

```python
phone_re = r"[0-9]{3}-[0-9]{3}-[0-9]{4}"
text  = "Sam's number is 382-384-3840 and Mary's is 123-456-7890."
re.findall(phone_re, text)
```

```ruby
['382-384-3840', '123-456-7890']
```

لنقوم بفصل كل ثلاث أو أربع أرقام لوحدها من رقم الهاتف، يمكننا جمع كل مجموعة أرقام داخل أقواس:

```python
# نفس التعبير السابق مع اضافة اقواس بين كل 3/4 ارقام
phone_re = r"([0-9]{3})-([0-9]{3})-([0-9]{4})"
text  = "Sam's number is 382-384-3840 and Mary's is 123-456-7890."
re.findall(phone_re, text)
```

```ruby
[('382', '384', '3840'), ('123', '456', '7890')]
```

كما توقعنا، `re.findall` تنتج لنا مجموعه تحتوي على جميع ما يطابق نمط أرقام الهواتف.

### RE.SUB

الدالة `re.sub(pattern, replacement, string)` تستبدل جميع تكرارات النمط المكتوب في المتغير `pattern` بالنص البديل في المتغير `replacement` في النص الموجود في المتغير `string`. هذه الدالة تعمل كما تعمل دالة `str.sub` في بايثون ولكن تستخدم التعبير النمطي.

في الكود البرمجي التالي، قمنا بتغير التواريخ لنحصل على تواريخ مطابقة بواسطة تبديل الفواصل إلى خطوط:

```python
messy_dates = '03/12/2018, 03.13.18, 03/14/2018, 03:15:2018'
regex = r'[/.:]'
re.sub(regex, '-', messy_dates)
```

```ruby
'03-12-2018, 03-13-18, 03-14-2018, 03-15-2018'
```

### RE.SPLIT

الدالة `re.split(pattern, string)` تقوم بفصل النص المدخل في المتغير `string` في كل مرة يظهر فيها النمط في المتغير `pattern`. تعمل هذه الدالة بنفس طريقة عمل دالة `str.split` في بايثون ولكن تستخدم التعبير النمطي لإتمام عملية الفصل.

في الكود البرمجي التالي، استخدمنا `re. split` لفصل أسماء الفصول من أرقام الصفحات في جدول محتوى الكتاب:

```python
toc = '''
PLAYING PILGRIMS============3
A MERRY CHRISTMAS===========13
THE LAURENCE BOY============31
BURDENS=====================55
BEING NEIGHBORLY============76
'''.strip()

# اولاً فصل كل سطر على حده
lines = re.split('\n', toc)
lines
```

```ruby
['PLAYING PILGRIMS============3',
 'A MERRY CHRISTMAS===========13',
 'THE LAURENCE BOY============31',
 'BURDENS=====================55',
 'BEING NEIGHBORLY============76']
```

```python
# ثم الفصل إلى اسم الفصل ورقم الصفحه
split_re = r'=+' # Matches any sequence of = characters
[re.split(split_re, line) for line in lines]
```

```ruby
[['PLAYING PILGRIMS', '3'],
 ['A MERRY CHRISTMAS', '13'],
 ['THE LAURENCE BOY', '31'],
 ['BURDENS', '55'],
 ['BEING NEIGHBORLY', '76']]
```

### التعابير النمطية و بانداز

تذكر أن مصفوفات بانداز تحتوي على دالة `.str` والتي تدعم دوال التعامل مع النصوص في بايثون. بنفس الطريقة، الدالة `.str` تدعم أيضا بعض الدوال من مكتبة `re`. سنشرح بعض الاستخدامات البسيطة للتعابير النمطية في بانداز وللمزيد من الدوال في [الصفحة الرئيسية لدوال النصوص في بانداز](https://pandas.pydata.org/pandas-docs/stable/user_guide/text.html).

قمنا بحفظ نص بسيط من أول خمس جمل من رواية *Little Women* في DataFrame. باستخدام دوال النصوص في بانداز يمكننا استخراج نصوص الحوارات المنطوقة في كل جمله:

```python
text = '''
"Christmas won't be Christmas without any presents," grumbled Jo, lying on the rug.
"It's so dreadful to be poor!" sighed Meg, looking down at her old dress.
"I don't think it's fair for some girls to have plenty of pretty things, and other girls nothing at all," added little Amy, with an injured sniff.
"We've got Father and Mother, and each other," said Beth contentedly from her corner.
The four young faces on which the firelight shone brightened at the cheerful words, but darkened again as Jo said sadly, "We haven't got Father, and shall not have him for a long time."
'''.strip()
little = pd.DataFrame({
    'sentences': text.split('\n')
})
```

```python
little
```

||**sentences**
:-----:|:-----:
0|<span style='font-size:1px'>a</span>"Christmas won't be Christmas without any pres...<span style='font-size:1px'>a</span>
1|<span style='font-size:1px'>a</span>"It's so dreadful to be poor!" sighed Meg, loo...<span style='font-size:1px'>a</span>
2|<span style='font-size:1px'>a</span>"I don't think it's fair for some girls to hav...<span style='font-size:1px'>a</span>
3|<span style='font-size:1px'>a</span>"We've got Father and Mother, and each other,"...<span style='font-size:1px'>a</span>
4|The four young faces on which the firelight sh...<span style='font-size:1px'>a</span>

بما أن الحوارات المنطوقة تُكتب بين علامتي الاقتباس، سنقوم بكتابة تعبير نمطي بحث عن علامتي الاقتباس، ويوجد داخلها أي نص عدا علامتي اقتباس أخرى، ويجب أن ينتهي النص بعلامة اقتباس:

```python
quote_re = r'"[^"]+"'
little['sentences'].str.findall(quote_re)
```

```ruby
0    ["Christmas won't be Christmas without any pre...
1                     ["It's so dreadful to be poor!"]
2    ["I don't think it's fair for some girls to ha...
3     ["We've got Father and Mother, and each other,"]
4    ["We haven't got Father, and shall not have hi...
Name: sentences, dtype: object
```

بما أن الدالة `Series.str.findall` توجد لنا جميع التطابقات، بانداز توفر لنا دالتي `Series.str.extract` و `Series.str.extractall` لاستخراج التطابقات إلى مصفوفة أو DataFrame. هذه الدوال تشرط علينا أن يحتوي التعبير النمطي على الأقل علي مجموعه واحده:

```python
# ايجاد النصوص بين علامتي اقتباس
quote_re = r'"([^"]+)"'
spoken = little['sentences'].str.extract(quote_re)
spoken
```

```ruby
0    Christmas won't be Christmas without any prese...
1                         It's so dreadful to be poor!
2    I don't think it's fair for some girls to have...
3         We've got Father and Mother, and each other,
4    We haven't got Father, and shall not have him ...
Name: sentences, dtype: object
```

يمكننا إضافة ذلك كعمود في `little`:

```python
little['dialog'] = spoken
little
```

||**sentences**|**dialog**|
:-----:|:-----:|:-----:
0|<span style='font-size:1px'>a</span>"Christmas won't be Christmas without any pres...<span style='font-size:1px'>a</span>|Christmas won't be Christmas without any prese...<span style='font-size:1px'>a</span>
1|<span style='font-size:1px'>a</span>"It's so dreadful to be poor!" sighed Meg, loo...<span style='font-size:1px'>a</span>|It's so dreadful to be poor!<span style='font-size:1px'>a</span>
2|<span style='font-size:1px'>a</span>"I don't think it's fair for some girls to hav...<span style='font-size:1px'>a</span>|I don't think it's fair for some girls to have...<span style='font-size:1px'>a</span>
3|<span style='font-size:1px'>a</span>"We've got Father and Mother, and each other,"...<span style='font-size:1px'>a</span>|We've got Father and Mother, and each other,<span style='font-size:1px'>a</span>
4|The four young faces on which the firelight sh...<span style='font-size:1px'>a</span>|We haven't got Father, and shall not have him ...<span style='font-size:1px'>a</span>

يمكننا أن نؤكد أن تلاعبنا بالنصوص باستخدام التعابير النمطية يعمل بالشكل الذي نرغب به في آخر جمله في ال DataFrame عن طريق طباعة النص الأصلي والنتيجة بعد المطابقة:

```python
print(little.loc[4, 'sentences'])
```

```ruby
The four young faces on which the firelight shone brightened at the cheerful words, but darkened again as Jo said sadly, "We haven't got Father, and shall not have him for a long time."
```

```python
print(little.loc[4, 'dialog'])
```

```ruby
We haven't got Father, and shall not have him for a long time.
```

#### ملخص التعابير النمطية في بايثون وبانداز

مكتبة `re` في بايثون توفر لنا الكثير من الدوال المفيدة للتلاعب بالنصوص باستخدام التعابير النمطية. عند العمل على DataFrame، نستخدم الدالة المماثلة للتلاعب بالنصوص باستخدام التعابير النمطية فيه بانداز.

لعرض كامل شرح مكتبة `re`، [اضغط هنا](https://docs.python.org/3/library/re.html).

لعرض كامل شرح دوال النصوص في بانداز، [اضغط هنا](https://pandas.pydata.org/pandas-docs/stable/text.html).